
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>KGT Routenplaner</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#0f172a">
    <link rel="manifest" href="manifest.webmanifest">
    <link rel="icon" type="image/png" href="KGT Routenplaner.png">
    <link rel="apple-touch-icon" href="KGT Routenplaner.png">


    <!-- Leaflet (OpenStreetMap) -->
    <link
        rel="stylesheet"
        href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
        crossorigin=""
    />
    <script
        src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
        crossorigin=""
    ></script>

    <style>
        :root {
            --bg-color: #f5f5f5;
            --bg-elevated: #ffffff;
            --text-color: #111111;
            --accent: #2563eb;
            --accent-soft: rgba(37, 99, 235, 0.08);
            --border-color: #e0e0e0;
            --shadow-soft: 0 10px 25px rgba(0,0,0,0.08);
        }
        body.dark {
            --bg-color: #0b1120;
            --bg-elevated: #020617;
            --text-color: #e5e7eb;
            --accent: #38bdf8;
            --accent-soft: rgba(56, 189, 248, 0.12);
            --border-color: #1e293b;
            --shadow-soft: 0 18px 40px rgba(15,23,42,0.7);
        }
        body.pink {
            --bg-color: #ffe4f2;
            --bg-elevated: #ffe4f2;
            --text-color: #4a044e;
            --accent: #8b5cf6;
            --accent-soft: rgba(139, 92, 246, 0.18);
            --border-color: #a855f7;
            --shadow-soft: 0 22px 50px rgba(139, 92, 246, 0.5);
        }

        * { box-sizing: border-box; }
        body {
            margin: 0;
            padding: 0;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            background: radial-gradient(circle at top, #e0f2fe 0, #f5f5f5 45%, #e5e7eb 100%);
            color: var(--text-color);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        body.dark {
            background: radial-gradient(circle at top, #0f172a 0, #020617 50%, #000 100%);
        }
        body.pink {
            background: radial-gradient(circle at top, #ffe4f2 0, #f472b6 32%, #f9a8d4 70%, #ffe4f2 100%);
        }

        header {
            position: sticky;
            top: 0;
            z-index: 700;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            padding: 6px 12px;
            background: rgba(248,250,252,0.98);
            border-bottom: 1px solid rgba(148,163,184,0.65);
            box-shadow: 0 2px 6px rgba(15,23,42,0.18);
        }
        body.dark header {
            background: rgba(15,23,42,0.96);
            border-bottom-color: rgba(51,65,85,0.9);
            box-shadow: 0 10px 26px rgba(0,0,0,0.7);
        }
        body.pink header {
            background: #ec4899;
            border-bottom-color: #be185d;
            box-shadow: 0 10px 28px rgba(190, 24, 93, 0.6);
        }
        body.pink header .toolbar-button {
            color: #fdf2f8;
        }
        body.pink header .toolbar-button.primary {
            color: #ffffff;
        }

        .header-left, .header-right {
            display: flex;
            align-items: center;
        }
.app-title {
    font-size: 18px;
    font-weight: 700;
    letter-spacing: 0.04em;
    color: #111111; /* Standard (heller Modus) */
}
body.dark .app-title {
    color: #ffffff;
}
body.pink .app-title {
    color: #4c1d95; /* gleiche Lila-Farbe wie die Buttons im Pink-Mode */
}

        .header-left {
            justify-content: flex-start;
        }
        .header-right {
            margin-left: auto;
            justify-content: flex-end;
        }

        .brand { display: flex; align-items: center; gap: 10px; }
        .brand-logo {
            width: 30px;
            height: 30px;
            border-radius: 12px;
            background: radial-gradient(circle at 30% 20%, #facc15, #f97316 40%, #ef4444 70%, #1d4ed8);
            box-shadow: 0 8px 20px rgba(0,0,0,0.25);
            position: relative;
            overflow: hidden;
        }
        .brand-logo::after {
            content: "";
            position: absolute;
            inset: 6px;
            border-radius: 999px;
            border: 2px solid rgba(255,255,255,0.7);
        }
        .brand-title { font-size: 17px; font-weight: 650; letter-spacing: 0.02em; }
        .brand-subtitle { font-size: 12px; opacity: 0.7; }
        .toolbar { display: flex; align-items: center; gap: 10px; }
        .toolbar-group {
            display: flex;
            gap: 6px;
            padding: 0;
            border-radius: 999px;
            background: transparent;
            border: none;
            box-shadow: none;
        }
        body.dark .toolbar-group {
            background: transparent;
            border: none;
            box-shadow: none;
        }
        .toolbar-button {
            border: none;
            background: transparent;
            padding: 5px 12px;
            border-radius: 999px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            color: var(--text-color);
            opacity: 0.9;
            transition: all 0.18s ease;
        }
        .header-right .toolbar-button {
            padding: 6px 14px;
            font-size: 14px;
        }

        .bottom-panel .toolbar-button {
            padding: 6px 14px;
            font-size: 14px;
        }

        .toolbar-button span.icon { font-size: 13px; }
        .toolbar-button:hover {
            background: rgba(148,163,184,0.16);
            opacity: 1;
            transform: translateY(-0.5px);
        }
        .toolbar-button.primary {
            background: var(--accent);
            color: white;
            opacity: 1;
            box-shadow: 0 9px 22px rgba(37, 99, 235, 0.45);
        }
        .toolbar-button.primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 15px 30px rgba(37, 99, 235, 0.6);
        }
        .toolbar-button.toggle { padding: 5px 10px; }
        .toggle-pill {
            width: 48px;
            height: 18px;
            border-radius: 999px;
            border: 1px solid rgba(148,163,184,0.8);
            background: rgba(148,163,184,0.28);
            position: relative;
            display: inline-flex;
            align-items: center;
            padding: 1px;
        }
        .toggle-thumb {
            width: 14px;
            height: 14px;
            border-radius: 999px;
            background: white;
            box-shadow: 0 3px 6px rgba(0,0,0,0.25);
            transform: translateX(0);
            transition: transform 0.2s ease;
        }
        body.dark .toggle-pill {
            background: rgba(15,23,42,0.8);
            border-color: rgba(55,65,81,0.8);
        }
        body.dark .toggle-thumb { transform: translateX(14px); }
        main {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        /* Container f√ºr Karte und Overlays */
        #mapContainer {
            position: relative;
            flex: 0 0 auto;
            height: calc(100vh - 86px); /* Karte so hoch, dass unten nur die Leiste sichtbar ist und die erste Route-Zeile unterhalb der Leiste beginnt */
            min-height: 320px;
        }
        #map {
            position: absolute;
            inset: 0;
        }
        .addresses-panel {
            position: absolute;
            top: 60px;
            right: 14px;
            width: 400px;
            max-height: calc(100% - 80px);
            display: flex;
            flex-direction: column;
            background: radial-gradient(circle at top, rgba(248,250,252,0.96), rgba(255,255,255,0.98));
            border-radius: 18px;
            box-shadow: var(--shadow-soft);
            border: 1px solid rgba(148,163,184,0.45);
            overflow: hidden;
            z-index: 500;
        }
        .addresses-resize-handle{
            position:absolute; top:0; left:0; width:6px; height:100%;
            cursor: ew-resize; background: transparent; z-index:10;
        }
        .addresses-resize-handle:hover{ background: rgba(148,163,184,0.18); }
        
        body.dark .addresses-panel {
            background: radial-gradient(circle at top, rgba(15,23,42,0.96), rgba(15,23,42,0.98));
        }
        body.pink .addresses-panel {
            background: linear-gradient(180deg, #ec4899, #db2777);
        }

        
        
        .panel-filter {
            padding: 6px 10px 4px;
            border-bottom: 1px solid rgba(148,163,184,0.25);
            background: rgba(248,250,252,0.9);
        }
        body.dark .panel-filter {
            background: rgba(15,23,42,0.96);
            border-bottom-color: rgba(148,163,184,0.35);
        }
        body.pink .panel-filter {
            background: rgba(236, 72, 153, 0.92);
            border-bottom-color: #be185d;
            color: #fdf2f8;
        }

        .panel-filter input {
            width: 100%;
            font-size: 13px;
            padding: 5px 11px;
            border-radius: 999px;
            border: 1px solid rgba(148,163,184,0.8);
            background: rgba(255,255,255,0.9);
            color: var(--text-color);
            outline: none;
        }
        body.dark .panel-filter input {
            background: rgba(15,23,42,0.95);
            border-color: rgba(148,163,184,0.9);
        }
        .panel-filter input::placeholder {
            color: rgba(148,163,184,0.9);
        }

/* Schrift im Adressen-Panel leicht vergr√∂√üert (ca. +10%) */
        .addresses-panel .panel-title { font-size: 17px; }
        .addresses-panel .status-text { font-size: 13px; }
        .addresses-panel .stop-item { font-size: 15px; }
        .addresses-panel .stop-address { font-size: 15px; }
        .addresses-panel .stop-meta { font-size: 13px; }
        .addresses-panel .stop-index { font-size: 14px; }
        /* Pink-Mode: Adressnummern-Badges mit deutlich mehr Schwarz im Kreis */
        body.pink .stop-item:not(.inactive) .stop-index {
            background: radial-gradient(circle at 30% 25%, #a855f7 0%, #6d28d9 25%, #020617 65%, #000000 100%);
            box-shadow: 0 4px 8px rgba(15, 23, 42, 0.7);
        }

        /* Dark-Mode: Adressnummern-Badges von hellblau nach dunkelblau verlaufend */
        body.dark .stop-item:not(.inactive) .stop-index {
            background: radial-gradient(circle at 30% 20%, #38bdf8 0%, #2563eb 45%, #0b1120 100%);
            box-shadow: 0 4px 8px rgba(15, 23, 42, 0.85);
        }

        .addresses-panel .badge { font-size: 13px; }
        .addresses-panel .panel-footer { font-size: 13px; }
        .addresses-panel .btn-small { font-size: 13px; }

        /* Pink-Theme: bessere Lesbarkeit im Adressen-Panel und in der unteren Leiste */
        body.pink .addresses-panel,
        body.pink .addresses-panel .panel-header,
        body.pink .addresses-panel .panel-title,
        body.pink .addresses-panel .status-text,
        body.pink .addresses-panel .stop-item,
        body.pink .addresses-panel .stop-address,
        body.pink .addresses-panel .stop-meta,
        body.pink .addresses-panel .panel-footer,
        body.pink .addresses-panel .summary-text {
            color: #ffffff;
        }
        body.pink .addresses-panel .badge {
            color: #ffffff;
            border-color: rgba(248,250,252,0.8);
        }

        body.pink .bottom-panel,
        body.pink .bottom-panel-header,
        body.pink .bottom-panel-header-left,
        body.pink .bottom-panel-summary,
        body.pink .bottom-panel-body,
        body.pink .bottom-route-list,
        body.pink .bottom-route-row,
        body.pink .bottom-route-index,
        body.pink .bottom-route-meta,
        body.pink .bottom-route-address,
        body.pink .bottom-route-empty,
        body.pink .bottom-route-summary-line,
        body.pink .route-loading {
            color: #ffffff;
        }
        body.pink .bottom-route-index,
        body.pink .bottom-route-meta {
            opacity: 0.95;
        }

        /* Pink-Theme: "Zur n√§chsten fehlerhaften Adresse"-Button besser lesbar */
        body.pink #faultyNextBtn {
            color: #ffffff;
            border-color: rgba(248,250,252,0.9);
            background: rgba(248,250,252,0.12);
        }
        body.pink #faultyNextBtn:hover {
            background: rgba(248,250,252,0.22);
        }

.panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            border-bottom: 1px solid rgba(148,163,184,0.4);
        }
        .panel-title { font-size: 13px; font-weight: 600; }
        .panel-close {
            border: none;
            background: transparent;
            font-size: 14px;
            cursor: pointer;
            opacity: 0.7;
        }
        .panel-close:hover { opacity: 1; }
        .stop-list {
            margin: 0;
            padding: 0;
            list-style: none;
            overflow-y: auto;
            flex: 1;
        }
        
        .stop-item.inactive {
            opacity: 0.6;
        }
        .stop-item.inactive .stop-index {
            background: #6b7280;
            box-shadow: 0 4px 8px rgba(15,23,42,0.4);
        }
.stop-item {
            display: flex;
            align-items: center;
            gap: 9px;
            padding: 7px 9px;
            font-size: 12px;
            cursor: pointer;
            border-bottom: 1px solid rgba(148,163,184,0.25);
            background: transparent;
            transition: background 0.15s ease, transform 0.1s ease;
        }
        .stop-item:last-child { border-bottom: none; }
        .stop-item:hover {
            background: rgba(148,163,184,0.16);
            transform: translateY(-0.5px);
        }
        .stop-item.active {
            background: var(--accent-soft);
            box-shadow: 0 0 0 1px rgba(37,99,235,0.35) inset;
        }
        
.stop-item[draggable="true"] { cursor: grab; }
/* Deutlichere Hervorhebung beim Drag&Drop: zeigt jetzt klar,
   ob der Stopp VOR oder HINTER einem Eintrag eingef√ºgt wird. */
.stop-item.drag-over {
    position: relative;
    background: rgba(148,163,184,0.16);
}
/* Linie OBERHALB: Einf√ºgen vor diesem Eintrag */
.stop-item.drag-over-top::before,
/* Linie UNTERHALB: Einf√ºgen hinter diesem Eintrag */
.stop-item.drag-over-bottom::after {
    content: "";
    position: absolute;
    left: 0;
    right: 0;
    height: 3px;
    background: rgba(37,99,235,0.95);
    box-shadow: 0 0 6px rgba(37,99,235,0.8);
    z-index: 1;
}
.stop-item.drag-over-top::before { top: -2px; }
.stop-item.drag-over-bottom::after { bottom: -2px; }

body.dark .stop-item.drag-over {
    background: rgba(15,23,42,0.75);
}
body.dark .stop-item.drag-over-top::before,
body.dark .stop-item.drag-over-bottom::after {
    background: rgba(56,189,248,0.95);
    box-shadow: 0 0 6px rgba(56,189,248,0.9);
}

body.pink .stop-item.drag-over {
    background: rgba(236,72,153,0.30);
}
body.pink .stop-item.drag-over-top::before,
body.pink .stop-item.drag-over-bottom::after {
    background: #f9a8d4;
    box-shadow: 0 0 6px rgba(244,114,182,0.95);
}
.stop-index {
            width: 24px;
            height: 24px;
            border-radius: 10px;
            background: radial-gradient(circle at 30% 20%, #f97316, #2563eb);
            color: white;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            box-shadow: 0 6px 10px rgba(15,23,42,0.4);
        }
        .stop-main { display: flex; flex-direction: column; min-width: 0; }
        .stop-address { font-size: 13px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .stop-meta { font-size: 12px; opacity: 0.8; }
        .panel-footer {
            padding: 6px 8px 8px 8px;
            border-top: 1px solid rgba(148,163,184,0.35);
            display: flex;
            flex-direction: column;
            gap: 4px;
            font-size: 11px;
        }
        .panel-footer-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 6px;
        }
        .badge {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 999px;
            border: 1px solid rgba(148,163,184,0.5);
            background: rgba(148,163,184,0.1);
        }
        .status-text { font-size: 11px; opacity: 0.8; }
        .summary-text { font-size: 11px; opacity: 0.9; }
        .btn-small {
            border-radius: 999px;
            border: 1px solid rgba(148,163,184,0.7);
            padding: 3px 9px;
            font-size: 11px;
            cursor: pointer;
            background: transparent;
            color: var(--text-color);
        }
        .btn-small:hover { background: rgba(148,163,184,0.15); }
        .modal-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(15,23,42,0.55);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 600;
        }
        .modal {
            width: min(660px, 94vw);
            background: radial-gradient(circle at top, rgba(248,250,252,0.98), rgba(255,255,255,0.99));
            border-radius: 16px;
            box-shadow: 0 22px 60px rgba(15,23,42,0.6);
            border: 1px solid rgba(148,163,184,0.7);
            padding: 10px 14px 12px 14px;
        }
        /* Breitere Modale nur f√ºr Routenverlauf & Favoriten */
        #routesModalBackdrop .modal,
        #favoritesModalBackdrop .modal {
            width: min(1150px, 98vw);
        }
        body.dark .modal {
            background: radial-gradient(circle at top, rgba(15,23,42,0.98), rgba(15,23,42,1));
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }
        .modal-title { font-size: 17px; font-weight: 600; }
        .modal-body { font-size: 14px; max-height: 70vh; overflow-y: auto; }
        .modal textarea {
            width: 100%;
            resize: vertical;
            min-height: 440px;
            max-height: 650px;
            border-radius: 10px;
            border: 1px solid rgba(148,163,184,0.8);
            padding: 8px;
            font-size: 15px;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            background: rgba(249,250,251,0.95);
            color: var(--text-color);
        }
        body.dark .modal textarea { background: rgba(15,23,42,0.95); }
        .modal textarea:focus,
        .modal textarea:focus-visible {
            outline: none;
            box-shadow: none;
            border-color: rgba(148,163,184,0.8);
        }
        .modal-footer {
            margin-top: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
        }
        .modal-buttons { display: flex; gap: 6px; }
        .btn-primary {
            border-radius: 999px;
            border: none;
            padding: 6px 14px;
            font-size: 12px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background: var(--accent);
            color: white;
            box-shadow: 0 9px 20px rgba(37,99,235,0.55);
        }
        body.pink .btn-primary,
        body.pink .toolbar-button.primary {
            background: #4c1d95;
            border-color: #3b0f77;
            box-shadow: 0 9px 22px rgba(76, 29, 149, 0.65);
            color: #ffffff;
        }
        body.pink .toolbar-button.primary:hover,
        body.pink .btn-primary:hover {
            box-shadow: 0 15px 30px rgba(90, 41, 182, 0.9);
            filter: brightness(1.05);
        }

        /* Im Pink-Mode: alle Buttons in ein dunkles, harmonisches Lila (#4c1d95) einf√§rben,
           damit sie ruhig, aber deutlich vom pinken Hintergrund abgegrenzt sind.
           Ausnahmen: Theme-Schalter, Fehlersuche-Buttons & echte Gefahren-/L√∂schen-Buttons. */
        body.pink .toolbar-button:not(.toggle):not(#faultyBtn):not(#faultyNextBtn) {
            background: #4c1d95;
            color: #ffffff;
        }
        body.pink .toolbar-button:not(.toggle):hover:not(#faultyBtn):not(#faultyNextBtn) {
            filter: brightness(1.06);
        }

        body.pink .btn-ghost {
            background: #4c1d95;
            color: #ffffff;
            border-color: #3b0f77;
        }
        body.pink .btn-ghost:hover {
            filter: brightness(1.06);
        }

        body.pink .btn-small:not(#faultyBtn):not(#faultyNextBtn) {
            background: #4c1d95;
            color: #ffffff;
            border-color: #3b0f77;
        }
        body.pink .btn-small:not(#faultyBtn):not(#faultyNextBtn):hover {
            filter: brightness(1.06);
        }

        body.pink .stop-menu-button {
            background: #4c1d95;
            color: #ffffff;
            border-color: #3b0f77;
        }
        body.pink .stop-menu-button:hover {
            filter: brightness(1.06);
        }
        /* Gefahren-Buttons im Kontextmen√º bleiben rot markiert */
        body.pink .stop-menu-button.danger {
            background: rgba(248,113,113,0.10);
            color: var(--text-color);
            border-color: rgba(248,113,113,0.9);
        }
        body.pink .stop-menu-button.danger:hover {
            background: rgba(239,68,68,0.20);
        }

        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 14px 26px rgba(37,99,235,0.65);
        }
        .btn-ghost {
            border-radius: 999px;
            border: 1px solid rgba(148,163,184,0.8);
            padding: 6px 12px;
            font-size: 12px;
            cursor: pointer;
            background: transparent;
            color: var(--text-color);
        }
        .btn-ghost:hover { background: rgba(148,163,184,0.15); }
        
        .btn-danger {
            border-radius: 999px;
            border: 1px solid rgba(248,113,113,0.9);
            padding: 6px 12px;
            font-size: 12px;
            cursor: pointer;
            background: transparent;
            color: var(--text-color);
        }
        .btn-danger:hover { background: rgba(239,68,68,0.14); }
.modal-hint { font-size: 11px; opacity: 0.8; }
        .link-like {
            border: none;
            background: none;
            color: var(--accent);
            font-size: 11px;
            cursor: pointer;
            text-decoration: underline;
            padding: 0;
        }
        .options-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px 16px;
            margin-top: 8px;
            align-items: flex-start;
        }
        .form-group { font-size: 12px; }
        .form-group label { font-weight: 500; display: block; margin-bottom: 2px; }
        .form-group input[type="time"],
        .form-group select {
            width: 100%;
            padding: 4px 6px;
            border-radius: 6px;
            border: 1px solid rgba(148,163,184,0.9);
            font-size: 12px;
            background: rgba(249,250,251,0.95);
            color: var(--text-color);
        }
        .form-group small { font-size: 11px; opacity: 0.8; }
        /* Dark-Mode-Optimierung f√ºr Optionen-Dialog */
        body.dark .modal {
            color: #e5e7eb;
        }
        body.dark .options-grid .form-group label,
        body.dark .options-grid .form-group small {
            color: #e5e7eb;
            opacity: 0.9;
        }
        body.dark .options-grid .form-group input[type="time"],
        body.dark .options-grid .form-group select,
        body.dark .options-grid .form-group input[type="text"] {
            background: rgba(15,23,42,0.95);
            color: #e5e7eb;
            border-color: rgba(148,163,184,0.9);
        }

        .routes-list {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
            margin-top: 4px;
        }
        .routes-list th, .routes-list td {
            border-bottom: 1px solid rgba(148,163,184,0.4);
            padding: 4px 6px;
            text-align: left;
        }
        .routes-list th { font-weight: 600; background: rgba(148,163,184,0.08); }
        .routes-list tr:hover td { background: rgba(148,163,184,0.08); }

        .routes-empty { font-size: 14px; opacity: 0.8; margin-top: 4px; }

        .routes-save-summary {
            font-size: 12px;
            margin-bottom: 8px;
            padding: 6px 8px;
            background: rgba(148,163,184,0.08);
            border-radius: 6px;
        }
        body.dark .routes-save-summary {
            background: rgba(30,64,175,0.25);
        }

        .stop-tooltip {
            background: rgba(17,24,39,0.95);
            color: #f9fafb;
            border-radius: 6px;
            padding: 2px 6px;
            border: 1px solid rgba(148,163,184,0.75);
            box-shadow: 0 6px 14px rgba(15,23,42,0.7);
            font-size: 11px;
        }
        .stop-tooltip.leaflet-tooltip-top:before {
            border-top-color: rgba(17,24,39,0.95);
        }

        body.dimmed .leaflet-tile {
            /* Planungsmodus: gleiche OSM-Standardkarte, aber in Graustufen
               mit leicht erh√∂htem Kontrast f√ºr bessere Lesbarkeit. */
            filter: grayscale(1) contrast(1.08) brightness(1.02);
        }

        .map-dim-overlay {
            position: absolute;
            inset: 0;
            background: rgba(15,23,42,0.35);
            z-index: 200;
            pointer-events: none;
        }
        .stop-menu {
            position: absolute;
            min-width: 260px;
            max-width: 320px;
            background: var(--bg-elevated);
            border-radius: 14px;
            box-shadow: 0 18px 40px rgba(15,23,42,0.55);
            border: 1px solid rgba(148,163,184,0.7);
            padding: 8px 10px 10px 10px;
            z-index: 550;
            transform: translate(-50%, -100%);
            display: none;
        }
        body.dark .stop-menu {
            background: radial-gradient(circle at top, rgba(15,23,42,0.98), rgba(15,23,42,1));
        }
        .stop-menu-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }
        .stop-menu-title {
            font-size: 13px;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .stop-menu-close {
            border: none;
            background: transparent;
            font-size: 14px;
            cursor: pointer;
            opacity: 0.7;
        }
        .stop-menu-close:hover { opacity: 1; }
        .stop-menu-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }
        .stop-menu-button {
            border-radius: 10px;
            border: 1px solid rgba(148,163,184,0.85);
            padding: 4px 8px;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            background: rgba(248,250,252,0.95);
        }
        .stop-menu-button span.icon {
            margin-right: 6px;
            font-size: 13px;
        }
        .stop-menu-button:hover {
            background: rgba(148,163,184,0.18);
        }
        body.dark .stop-menu-button {
            background: rgba(15,23,42,0.95);
        }
        .stop-menu-button.danger {
            border-color: rgba(248,113,113,0.9);
        }
        .stop-menu-button.danger:hover {
            background: rgba(239,68,68,0.14);
        }
        .stop-menu-note {
            font-size: 11px;
            opacity: 0.78;
            margin-top: 6px;
        }

        /* Leaflet Marker als runde Badge mit Zahl */
        .leaflet-div-icon.stop-marker {
            background: #020617;
            border-radius: 6px;
            color: white;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 13px;
            font-weight: 600;
            border: 2px solid white;
            box-shadow: 0 6px 10px rgba(15,23,42,0.7);
        }
        .leaflet-div-icon.stop-marker.stop-marker-start {
            background: #16a34a;
        }
        .leaflet-div-icon.stop-marker.stop-marker-end {
            background: #dc2626;
        }
        .leaflet-div-icon.stop-marker.stop-marker-mid {
            background: #020617;
        }

        .leaflet-div-icon.stop-marker.stop-marker-inactive {
            background: #6b7280;
            opacity: 0.7;
        }
        .leaflet-div-icon.stop-marker-active {
            transform: scale(1.08);
            box-shadow: 0 0 0 3px rgba(59,130,246,0.9);
        }

        
        .map-search {
            position: absolute;
            top: 24px;
            left: 16px;
            transform: none;
            z-index: 550;
            display: flex;
            align-items: center;
            gap: 6px;
            background: rgba(255, 255, 255, 0.96);
            padding: 4px 10px;
            border-radius: 999px;
            border: 1px solid rgba(148, 163, 184, 0.85);
            min-width: 480px;
            max-width: 640px;
        }
        body.pink .map-search {
            background: #ffffff; /* im Pink-Mode: Inhalt komplett wei√ü innerhalb des pinken Rahmens */
            border-color: rgba(244, 114, 182, 0.9);
        }

        body.dark .map-search {
            background: rgba(15, 23, 42, 0.98);
            border-color: rgba(51, 65, 85, 0.9);
        }
        .map-search input {
            border: none;
            outline: none;
            background: transparent;
            font-size: 13px;
            flex: 1;
            color: var(--text-color);
        }
        body.pink .map-search input {
            background: #ffffff;
        }
        .map-search input::placeholder {
            color: var(--muted-text);
        }
        .map-search button {
            border-radius: 999px;
            border: none;
            padding: 4px 14px;
            font-size: 12px;
            cursor: pointer;
            background: var(--accent);
            color: #fff;
            font-weight: 500;
            white-space: nowrap;
        }
        body.pink .map-search button {
            background: #4c1d95;
            color: #ffffff;
        }
        .map-search button:hover {
            filter: brightness(1.08);
        }

        .bottom-panel {
            background: rgba(248,250,252,0.98);
            border-top: 1px solid rgba(148,163,184,0.65);
            box-shadow: 0 -4px 12px rgba(15,23,42,0.18);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            }

        body.dark .bottom-panel {
            background: rgba(15,23,42,0.96);
            border-top-color: rgba(51,65,85,0.9);
            box-shadow: 0 -10px 26px rgba(0,0,0,0.7);
        }
        body.pink .bottom-panel {
            background: #ec4899;
            border-top-color: #be185d;
            box-shadow: 0 -12px 30px rgba(190, 24, 93, 0.5);
        }

        .bottom-panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            padding: 7px 12px 7px;
        }
        .bottom-panel-header-left {
            display: flex;
            gap: 6px;
            align-items: center;
        }
        .bottom-panel-summary {
            font-size: 12px;
            color: var(--muted-text);
            white-space: nowrap;
            display: none; /* Anzeige nur in der Liste am Ende */
        }
        .route-loading {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: var(--muted-text);
            white-space: nowrap;
        }
        .loader-circle {
            width: 14px;
            height: 14px;
            border-radius: 999px;
            border: 2px solid rgba(148,163,184,0.6);
            border-top-color: var(--accent);
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .bottom-panel-body {
            padding: 7px 12px 7px;
            display: none; /* Wird erst eingeblendet, wenn eine Route vorhanden ist */
            min-height: 110px; /* sorgt daf√ºr, dass bei vorhandener Route die Seite wirklich h√∂her als das Viewport ist und man mit dem Mausrad nach unten zur Routenliste scrollen kann */
        }
        .bottom-route-list {
            font-size: 13px;
            padding-right: 6px;
        }
        .bottom-route-row {
            display: grid;
            grid-template-columns: 30px 120px minmax(0, 1fr);
            align-items: baseline;
            gap: 6px;
            padding: 5px 0;
            border-bottom: 1px solid rgba(148,163,184,0.25);
            cursor: pointer;
        }
        .bottom-route-row:last-child {
            border-bottom: none;
        }
        .bottom-route-row:hover {
            background: rgba(148,163,184,0.12);
        }
        .bottom-route-index {
            font-weight: 600;
            color: var(--muted-text);
        }
        .bottom-route-meta {
            color: var(--muted-text);
        }
        .bottom-route-address {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .bottom-route-empty {
            font-size: 12px;
            color: var(--muted-text);
        }
        .bottom-route-summary-line {
            margin-top: 6px;
            padding-top: 4px;
            border-top: 1px solid rgba(148,163,184,0.4);
            font-size: 12px;
            font-weight: 600;
            color: var(--text-color);
        }

        /* Zoom-Control etwas h√∂her setzen, damit es nicht mit der Leiste kollidiert */
        .leaflet-bottom.leaflet-left {
            bottom: 10px;
        }

@media (max-width: 900px) {
            .addresses-panel { width: 270px; }
            .options-grid { grid-template-columns: 1fr; }
        }
    

        /* Spezielle Hervorhebung f√ºr den Button "Fehlerhafte Adressen" */
        #faultyBtn {
            background: #DB2524;
            color: #ffffff;
        }

        #faultyBtn:hover {
            opacity: 1;
            filter: brightness(1.05);
        }
</style>
</head>
<body class="light">
<header>
    <div class="header-left"><div class="app-title">KGT Routenplaner</div></div>
    <div class="header-right">
        <div class="toolbar-group">
            <button class="toolbar-button primary" id="menuImport"><span class="icon">‚¨áÔ∏è</span><span>Einf√ºhren</span></button>
            <button class="toolbar-button" id="menuAddresses"><span class="icon">üìç</span><span>Adressen</span></button>
            <button class="toolbar-button" id="menuRoutes"><span class="icon">üó∫Ô∏è</span><span>Routen</span></button>
            <button class="toolbar-button" id="menuDim"><span class="icon">üëÅÔ∏è</span><span>Ansicht</span></button>
            <button class="toolbar-button" id="menuOptions"><span class="icon">‚öôÔ∏è</span><span>Optionen</span></button>
            <button class="toolbar-button toggle" id="themeToggle" title="Hell/Dunkel/Pink umschalten">
                <span class="icon" id="themeIcon">üåû</span>
                <span class="toggle-pill"><span class="toggle-thumb"></span></span>
            </button>
        </div>
    </div>
</header>

<main>
    <div id="mapContainer">

    <div id="mapSearch" class="map-search">
        <input id="mapSearchInput" type="text" placeholder="Adresse eingeben">
        <button id="mapSearchBtn">Suchen</button>
    </div>

    <div id="map"></div>
    <div id="mapDimOverlay" class="map-dim-overlay" style="display:none;"></div>

    
    <aside class="addresses-panel" id="addressesPanel">
        <div class="addresses-resize-handle" id="addressesResizeHandle" title="Breite anpassen"></div>
        <div class="panel-header">
            <div>
                <div class="panel-title">Adressen</div>
                <div class="status-text" id="panelStatus">Keine Stopps geladen.</div>
            </div>
            <button class="panel-close" id="panelCloseBtn" title="Panel ein-/ausblenden">‚úï</button>
        </div>
        <div class="panel-filter">
            <input type="text" id="addressFilterInput" placeholder="Liste filtern ‚Ä¶" autocomplete="off" />
        </div>
        <ul class="stop-list" id="stopList"></ul>
        <div class="panel-footer">
            <div class="panel-footer-top">
                <span class="badge" id="stopCount">0 Stopps</span>
                <button class="btn-small" id="faultyNextBtn" style="display:none;" title="Zur n√§chsten fehlerhaften Adresse springen">‚ñ∂</button>
                <button class="btn-small" id="faultyBtn" style="display:none;">Fehlerhafte Adressen</button>
                <button class="btn-small" id="resetBtn">Zur√ºcksetzen</button>
            </div>
            <div class="summary-text" id="summaryInfo">Gesamt: ‚Äì</div>
        </div>
    </aside>

    <div id="stopMenu" class="stop-menu">
        <div class="stop-menu-header">
            <div class="stop-menu-title" id="stopMenuTitle">Stopp</div>
            <button class="stop-menu-close" id="stopMenuCloseBtn">‚úï</button>
        </div>
        <div class="stop-menu-grid">
            <button class="stop-menu-button" id="stopMenuStartBtn"><span class="icon">üèÅ</span><span>Als Start</span></button>
            <button class="stop-menu-button" id="stopMenuEndBtn"><span class="icon">üèÅ</span><span>Als Ziel</span></button>
            <button class="stop-menu-button" id="stopMenuZoomBtn"><span class="icon">üîç</span><span>Zoom</span></button>
            <button class="stop-menu-button" id="stopMenuMoveBtn"><span class="icon">üß≠</span><span>Navigieren</span></button>
            <button class="stop-menu-button" id="stopMenuStreetBtn"><span class="icon">üõ∞Ô∏è</span><span>Street View</span></button>
            <button class="stop-menu-button" id="stopMenuEditBtn"><span class="icon">‚úèÔ∏è</span><span>Bearbeiten</span></button>
            <button class="stop-menu-button" id="stopMenuToggleActiveBtn"><span class="icon">‚úÖ</span><span>Inaktiv setzen</span></button>
            <button class="stop-menu-button danger" id="stopMenuDeleteBtn"><span class="icon">üóëÔ∏è</span><span>Entfernen</span></button>
        </div>
        <div class="stop-menu-note">Tipp: Reihenfolge kannst du zus√§tzlich rechts in der Liste per Ziehen √§ndern.</div>
    </div>


    <!-- Einf√ºhren-Dialog -->
    </div>

<div id="bottomPanel" class="bottom-panel">
        <div class="bottom-panel-header">
            <div class="bottom-panel-header-left">
                <button class="toolbar-button" id="menuSave"><span class="icon">üíæ</span><span>Speichern</span></button>
                <button class="toolbar-button" id="menuPrint"><span class="icon">üñ®Ô∏è</span><span>Drucken</span></button>
                <button class="toolbar-button" id="menuDelete"><span class="icon">üóëÔ∏è</span><span>L√∂schen</span></button>
                <button class="toolbar-button" id="menuRouteCalc"><span class="icon">üßÆ</span><span>Route berechnen</span></button>
                <button class="toolbar-button" id="menuViewFullRoute"><span class="icon">üåê</span><span>Gesamtroute</span></button>
            
                <button class="toolbar-button" id="menuRoutesImport"><span class="icon">‚¨áÔ∏è</span><span>Import</span></button>
                <button class="toolbar-button" id="menuRoutesExport"><span class="icon">‚¨ÜÔ∏è</span><span>Export</span></button>
            </div>
            <div class="bottom-panel-summary" id="bottomSummaryInfo">Gesamt: ‚Äì</div>
            <div id="routeLoadingIndicator" class="route-loading" style="display:none;">
                <span class="loader-circle"></span>
                <span class="route-loading-text">Berechne Route ‚Ä¶</span>
            </div>
        </div>
        <div class="bottom-panel-body">
            <div id="bottomRouteList" class="bottom-route-list">
                <div class="bottom-route-empty">Noch keine Stopps geladen.</div>
            </div>
        </div>
    </div>


    
<div class="modal-backdrop" id="importModalBackdrop">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title">Adressen einf√ºhren</div>
                <button class="panel-close" id="modalCloseBtn">‚úï</button>
            </div>
            <div class="modal-body">
                <p>Gib Adressen ein. <strong>Eine Adresse pro Zeile</strong>. Unn√∂tige Leerzeichen, doppelte Eintr√§ge und einfache Sonderzeichen werden bereinigt.</p>
                <textarea id="modalAddressInput" placeholder="Eine Adresse pro Zeile, z.B. Musterstra√üe 1, 12345 Musterstadt"></textarea>
                <div id="importAddressCount" class="modal-hint" style="margin-top:4px;">
                    Aktuell: 0 Adressen (0 Zeilen, nur nicht-leere Zeilen werden gez√§hlt).
                </div>
                <div class="modal-footer">
                    <div class="modal-hint">
                        Tipp: Du kannst Adressen direkt aus einer Excel-Spalte oder E-Mail hineinkopieren.
                        <br><button class="link-like" id="clearListBtn">Liste leeren</button>
                    </div>
                    <div class="modal-buttons">
                        <button class="btn-ghost" id="modalCancelBtn">Abbrechen</button>
                        <button class="btn-primary" id="modalImportBtn"><span>Einf√ºhren</span><span>‚èé</span></button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Optionen-Dialog -->
    <div class="modal-backdrop" id="optionsModalBackdrop">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title">Optionen</div>
                <button class="panel-close" id="optionsCloseBtn">‚úï</button>
            </div>
            <div class="modal-body">
                <p>Diese Einstellungen wirken sich auf die Bereinigung und Darstellung aus. Sie werden im Browser gespeichert.</p>
                <div class="options-grid">
                    <div class="form-group">
                        <label for="optStartTime">Standard-Startzeit</label>
                        <input type="time" id="optStartTime" value="07:30">
                        <small>Wird sp√§ter f√ºr Zeitplanung (Vormittag/Nachmittag) genutzt.</small>
                    </div>
                    <div class="form-group">
                        <label for="optRangeHandling">Hausnummer-Bereiche (‚Äû3‚Äì19‚Äú)</label>
                        <select id="optRangeHandling">
                            <option value="first">Erste Nummer verwenden (3)</option>
                            <option value="last">Letzte Nummer verwenden (19)</option>
                        </select>
                        <small>Gilt beim Einlesen von Adressen mit Nummern-Bereichen.</small>
                    </div>
                    <div class="form-group">
                        <label for="optAutoNormalize">Adress-Autokorrektur</label>
                        <select id="optAutoNormalize">
                            <option value="on">M√∂glichst automatisch bereinigen</option>
                            <option value="off">Nur einfache Bereinigung</option>
                        </select>
                        <small>Wenn ‚Äûaus‚Äú, werden nur Leerzeichen & einfache Zeichen bereinigt.</small>
                    </div>
                    <div class="form-group">
                        <label for="optUnit">Einheit</label>
                        <select id="optUnit">
                            <option value="km">Kilometer (Standard)</option>
                            <option value="m">Meter (nur sehr kurze Routen)</option>
                        </select>
                        <small>Nur Anzeige ‚Äì die Daten kommen vom Routingdienst in Metern.</small>
                    </div>
                </div>
                <div style="margin-top:10px; font-size:11px; opacity:0.8;">
                    Hinweis: In dieser Demo werden OpenStreetMap (Karte), Nominatim (Geocoding) und OSRM (Routing)
                    als √∂ffentliche Dienste genutzt. F√ºr sehr viele t√§gliche Anfragen w√§re sp√§ter ein eigener Server sinnvoll.
                </div>
                <div class="modal-footer">
                    <span class="modal-hint">Einstellungen werden in diesem Browser gespeichert.</span>
                    <div class="modal-buttons">
                        <button class="btn-ghost" id="optionsResetBtn">Auf Standard zur√ºcksetzen</button>
                        <button class="btn-primary" id="optionsSaveBtn">Speichern</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Routen-Historie-Dialog -->
    <div class="modal-backdrop" id="routesModalBackdrop">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title">Routenverlauf</div>
                <button class="panel-close" id="routesCloseBtn">‚úï</button>
            </div>
            <div class="modal-body">
                <p>Hier werden automatisch die zuletzt verwendeten Routen gespeichert (max. 50 Eintr√§ge, nur lokal in diesem Browser).</p>
                <div id="routesListContainer"></div>
                <div class="modal-footer">
                    <span class="modal-hint">Routenverlauf wird lokal auf diesem Ger√§t gespeichert.</span>
                    <div class="modal-buttons">
                        <button class="btn-ghost" id="routesImportBtn">Import</button>
                        <button class="btn-ghost" id="routesDownloadBtn">Export</button>
                        <button class="btn-ghost" id="routesClearBtn">Alles l√∂schen</button>
                        <button class="btn-ghost" id="routesFavoritesBtn">Favoriten</button>
                        <button class="btn-primary" id="routesCloseBtn2">Schlie√üen</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Favoriten-Dialog -->
    <div class="modal-backdrop" id="favoritesModalBackdrop">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title">Favoriten</div>
                <button class="panel-close" id="favoritesCloseBtn">‚úï</button>
            </div>
            <div class="modal-body">
                <p>Hier kannst du deine selbst gespeicherten Routen-Favoriten ansehen, √∂ffnen und verwalten.</p>
                <div id="favoritesListContainer"></div>
                <div class="modal-footer">
                    <span class="modal-hint">Favoriten werden dauerhaft lokal auf diesem Ger√§t gespeichert.</span>
                    <div class="modal-buttons">
                        <button class="btn-ghost" id="favoritesImportBtn">Import</button>
                        <button class="btn-ghost" id="favoritesDownloadBtn">Export</button>
                        <button class="btn-ghost" id="favoritesClearBtn">Alle l√∂schen</button>
                        <button class="btn-primary" id="favoritesCloseBtn2">Schlie√üen</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Route als Favorit speichern-Dialog -->
    <div class="modal-backdrop" id="favoriteSaveModalBackdrop">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title">Route als Favorit speichern</div>
                <button class="panel-close" id="favoriteSaveCloseBtn">‚úï</button>
            </div>
            <div class="modal-body">
                <div id="favoriteSaveSummary" class="routes-save-summary"></div>
                <div class="form-group">
                    <label for="favoriteNameInput">Name des Favoriten</label>
                    <input type="text" id="favoriteNameInput" style="width:100%;padding:4px 6px;border-radius:6px;border:1px solid rgba(148,163,184,0.8);" />
                </div>
                <div class="modal-footer">
                    <span class="modal-hint">Diese Route wird zus√§tzlich als Favorit gespeichert.</span>
                    <div class="modal-buttons">
                        <button class="btn-ghost" id="favoriteSaveCancelBtn">Abbrechen</button>
                        <button class="btn-primary" id="favoriteSaveConfirmBtn">Speichern</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    
    <!-- Warnhinweis-Dialog f√ºr fehlerhafte Adressen -->
    <div class="modal-backdrop" id="faultyWarnModalBackdrop" style="display:none;">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title">Nicht erkannte Adressen</div>
                <button class="panel-close" id="faultyWarnCloseBtn">‚úï</button>
            </div>
            <div class="modal-body">
                <p id="faultyWarnMessage">Einige Adressen konnten nicht erkannt werden.</p>
                <div id="faultyWarnList" style="max-height:260px; overflow:auto; margin-top:8px;"></div>
                <div class="modal-footer">
                    <div style="display:flex;flex-direction:column;gap:4px;">
                        <span class="modal-hint">Klicke auf eine Adresse, um sie direkt zu bearbeiten.</span>
                        <label style="font-size:11px;opacity:0.9;display:flex;align-items:center;gap:4px;cursor:pointer;">
                            <input type="checkbox" id="faultyWarnHideResolved" style="margin:0;">
                            Erledigte Adressen ausblenden
                        </label>
                    </div>
                    <div class="modal-buttons">
                        <button class="btn-primary" id="faultyWarnOkBtn">OK</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

<!-- Stopp bearbeiten-Dialog -->
<!-- Stopp bearbeiten-Dialog -->
    <div class="modal-backdrop" id="stopEditModalBackdrop">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title">Stopp bearbeiten</div>
                <button class="panel-close" id="stopEditCloseBtn">‚úï</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="stopEditAddress">Adresse</label>
                    <input type="text" id="stopEditAddress" style="width:100%;padding:4px 6px;border-radius:6px;border:1px solid rgba(148,163,184,0.9);font-size:12px;background:rgba(249,250,251,0.95);color:var(--text-color);" />
                </div>
                <div class="form-group" style="margin-top:6px;">
                    <label for="stopEditNotes">Notizen</label>
                    <textarea id="stopEditNotes" style="min-height:70px;"></textarea>
                </div>
                <div class="options-grid" style="margin-top:8px;">
                    <div class="form-group">
                        <label for="stopEditEarliest">Fr√ºhestens</label>
                        <input type="time" id="stopEditEarliest">
                        <small>(uu:mm)</small>
                    </div>
                    <div class="form-group">
                        <label for="stopEditLatest">Sp√§testens</label>
                        <input type="time" id="stopEditLatest">
                        <small>(uu:mm)</small>
                    </div>
                    <div class="form-group">
                        <label for="stopEditWindow">Zeitfenster</label>
                        <select id="stopEditWindow">
                            <option value="">Kein spezielles Fenster</option>
                            <option value="morning">Nur vormittags</option>
                            <option value="afternoon">Nur nachmittags</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="stopEditDuration">Dauer vor Ort</label>
                        <input type="time" id="stopEditDuration" value="00:05">
                        <small>(uu:mm ‚Äì Infofeld f√ºr Planung)</small>
                    </div>
                </div>
                <div class="options-grid" style="margin-top:8px;">
                    <div class="form-group">
                        <label for="stopEditBefore">Besuchen vor</label>
                        <select id="stopEditBefore">
                            <option value="">(keine Vorgabe)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="stopEditAfter">Besuchen nach</label>
                        <select id="stopEditAfter">
                            <option value="">(keine Vorgabe)</option>
                        </select>
                    </div>
                </div>
                <div style="margin-top:8px;font-size:11px;opacity:0.8;">
                    Hinweis: In dieser Demo werden die Zeitfenster noch nicht in der Optimierung ber√ºcksichtigt, aber alle Angaben werden gespeichert und in der Vollversion nutzbar gemacht.
                </div>
                <div class="modal-footer">
                    <span class="modal-hint">√Ñnderungen gelten nur f√ºr diesen Stopp.</span>
                    <div class="modal-buttons">
                        <button class="btn-danger" id="stopEditDeleteBtn">Stopp entfernen</button>
                        <button class="btn-ghost" id="stopEditCancelBtn">Abbrechen</button>
                        <button class="btn-primary" id="stopEditSaveBtn">Speichern</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

</main>

<script>
    let map;
    let routeLayer = null;
    let routeComputed = false;
    let baseLayerNormal = null;
    let baseLayerGray = null;
    let markers = [];
    let stops = []; // { raw, cleaned, lat, lon, ... }
    let activeIndex = null;
    let addressesPanelVisible = true;
    let faultyAddresses = [];
    let faultyNavIndex = -1;

    const SETTINGS_KEY = "routenplaner_osm_settings_v1";
    const ROUTES_KEY = "routenplaner_osm_routes_v1";
    const FAVORITES_KEY = "routenplaner_osm_favorites_v1";
    const OPTIMIZATION_MAX_ACTIVE_STOPS = 90; // Maximale Anzahl Stopps f√ºr automatische Optimierung

const ROUTES_FS_DB_NAME = "kgt_routenplaner_routes_fs";
const ROUTES_FS_STORE = "handles";
const ROUTES_FS_KEY = "routesDir";
let routesDirectoryHandle = null;
let routesDirectoryHandleLoaded = false;



    let currentSettings = loadSettings();
    let stopMenuIndex = null;
    let currentEditIndex = null;
    let currentDraggableMarker = null;
    let mapDimmed = false;

    function loadSettings() {
        let defaults = {
            startTime: "07:30",
            rangeHandling: "first",
            autoNormalize: "on",
            unit: "km",
            theme: "light"
        };
        try {
            const stored = localStorage.getItem(SETTINGS_KEY);
            if (stored) {
                const parsed = JSON.parse(stored);
                return Object.assign(defaults, parsed);
            }
        } catch (e) {
            console.warn("Konnte Einstellungen nicht laden:", e);
        }
        return defaults;
    }

    function saveSettings(settings) {
        try {
            localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
        } catch (e) {
            console.warn("Konnte Einstellungen nicht speichern:", e);
        }
    }

    function initMap() {
        const startCenter = [51.163375, 10.447683];
        map = L.map("map", { zoomControl: false, attributionControl: false }).setView(startCenter, 6);

        // Zoom-Steuerung unten links
        L.control.zoom({ position: "bottomleft" }).addTo(map);

        // OpenStreetMap.Default ‚Äì volle Details und Beschriftungen
        baseLayerNormal = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
            maxZoom: 19,
            attribution: ""
        });

        // Nur eine Kartenquelle ‚Äì der Graumodus wird per CSS-Filter erzeugt
        mapDimmed = true; // Standard: Planungs-/Graumodus beim Start
        document.body.classList.add("dimmed");
        baseLayerNormal.addTo(map);
    }


    function searchMapAddress() {
        const input = document.getElementById("mapSearchInput");
        if (!input) return;
        const query = input.value.trim();
        if (!query) return;

        fetch("https://nominatim.openstreetmap.org/search?format=json&limit=1&q=" + encodeURIComponent(query))
            .then((resp) => resp.json())
            .then((results) => {
                if (results && results.length > 0) {
                    const r0 = results[0];
                    const lat = parseFloat(r0.lat);
                    const lon = parseFloat(r0.lon);
                    if (!isNaN(lat) && !isNaN(lon) && map) {
                        map.setView([lat, lon], 16);
                    }
                } else {
                    alert("Adresse konnte nicht gefunden werden.");
                }
            })
            .catch((err) => {
                console.error("Fehler bei der Adresssuche:", err);
                alert("Bei der Adresssuche ist ein Fehler aufgetreten.");
            });
    }

    function setPanelStatus(msg) {
        const el = document.getElementById("panelStatus");
        if (el) el.textContent = msg;
    }

    function updateStopCount() {
        const el = document.getElementById("stopCount");
        const count = stops.length;
        if (!el) return;
        el.textContent = (count === 1) ? "1 Stopp" : count + " Stopps";
    }

    function setSummary(text) {
        const el = document.getElementById("summaryInfo");
        if (el) el.textContent = text;
        const el2 = document.getElementById("bottomSummaryInfo");
        if (el2) el2.textContent = text;
    }

    function updateImportAddressCount() {
        const ta = document.getElementById("modalAddressInput");
        const info = document.getElementById("importAddressCount");
        if (!ta || !info) return;

        const value = ta.value || "";
        const lines = value.split(/\r?\n/);
        let nonEmpty = 0;
        for (let line of lines) {
            if (line.trim() !== "") nonEmpty++;
        }

        let msg = "";
        if (nonEmpty === 0) {
            msg = "Aktuell: 0 Adressen (0 Zeilen, nur nicht-leere Zeilen werden gez√§hlt).";
        } else if (nonEmpty === 1) {
            msg = "Aktuell: 1 Adresse (1 Zeile, nur nicht-leere Zeilen werden gez√§hlt).";
        } else {
            msg = "Aktuell: " + nonEmpty + " Adressen (" + nonEmpty + " Zeilen, nur nicht-leere Zeilen werden gez√§hlt).";
        }

        if (typeof OPTIMIZATION_MAX_ACTIVE_STOPS === "number") {
            msg += " Optimierung bis ca. " + OPTIMIZATION_MAX_ACTIVE_STOPS + " Stopps.";
        }

        info.textContent = msg;

        if (typeof OPTIMIZATION_MAX_ACTIVE_STOPS === "number" && nonEmpty > OPTIMIZATION_MAX_ACTIVE_STOPS) {
            info.style.color = "#b91c1c";
            info.style.fontWeight = "600";
        } else {
            info.style.color = "";
            info.style.fontWeight = "";
        }
    }

    
    
    function rerouteIfAlreadyComputed(contextMessage) {
        // Nutzt die aktuelle Stoppreihenfolge, um ‚Äì falls bereits eine Route existiert ‚Äì
        // automatisch eine neue Route zu berechnen.
        if (!routeComputed) {
            if (contextMessage) {
                setPanelStatus(
                    contextMessage +
                    " Klicke unten auf 'Route berechnen', um eine Route zu erhalten."
                );
            }
            return;
        }

        if (contextMessage) {
            setPanelStatus(
                contextMessage +
                " Route wird anhand der aktuellen Reihenfolge neu berechnet ‚Ä¶"
            );
        } else {
            setPanelStatus("Route wird anhand der aktuellen Reihenfolge neu berechnet ‚Ä¶");
        }

        // Bei √Ñnderungen √ºber den Stopp-Dialog wird die aktuelle Reihenfolge respektiert.
        // Es wird nur die Route neu berechnet, ohne eine erneute globale Optimierung.
        buildRouteFromLocations({ skipOptimization: true });
    }


    // Lokale Neu-Optimierung nach manueller √Ñnderung der Reihenfolge (Drag & Drop).
    // Der verschobene Stopp bleibt an seiner neuen Position im aktiven Teil der Route fix,
    // die √ºbrigen Stopps dahinter werden ‚Äì soweit sinnvoll ‚Äì neu optimiert.
    function rerouteAfterManualReorder(anchorStopIndex) {
        if (!routeComputed) {
            // Es gibt noch keine berechnete Route ‚Äì Reihenfolge nur merken.
            setPanelStatus(
                "Reihenfolge ge√§ndert. Klicke unten auf 'Route berechnen', um eine Route zu erhalten."
            );
            return;
        }

        // Versuche eine Suffix-Optimierung ab dem verschobenen Stopp:
        // 1. Alle Stopps bis zum Anker bleiben unver√§ndert.
        // 2. Ab dem Anker bis zum letzten aktiven/geokodierten Stopp wird neu optimiert.
        const changed = reoptimizeRouteWithAnchor(anchorStopIndex);

        if (!changed) {
            // Fallback: keine Optimierung m√∂glich (z.B. zu wenige Stopps oder zu viele aktive Stopps).
            // In diesem Fall wird die Route einfach in der aktuellen Reihenfolge neu berechnet.
            setPanelStatus(
                "Reihenfolge ge√§ndert. Route wird anhand der aktuellen Reihenfolge neu berechnet ‚Ä¶"
            );
            buildRouteFromLocations({ skipOptimization: true });
            return;
        }

        // Suffix wurde erfolgreich neu optimiert ‚Äì Route mit dieser neuen Reihenfolge neu berechnen,
        // ohne die globale Optimierung erneut anzusto√üen, damit die neue Suffix-Reihenfolge erhalten bleibt.
        setPanelStatus(
            "Reihenfolge ge√§ndert. Route wird ab diesem Stopp neu optimiert ‚Ä¶"
        );
        buildRouteFromLocations({ skipOptimization: true });
    }

function normalizeAddressText(text) {
        // Intelligente, aber vorsichtige Normalisierung von Adresszeilen.
        // Greift nur, wenn in den Optionen "Adress-Autokorrektur" = AN ist.
        if (!currentSettings || currentSettings.autoNormalize !== "on") return text;

        if (!text) return text;
        let value = String(text).trim();
        if (!value) return value;

        // 1) Mehrfache Leerzeichen vereinheitlichen (Sicherheit)
        value = value.replace(/\s+/g, " ");

        // 2) H√§ufige Abk√ºrzungen und Schreibweisen f√ºr "Stra√üe" korrigieren.
        //    Wir arbeiten mit einer Hilfs-Kleinbuchstaben-Variante, ersetzen aber im Original-String.
        let lower = value.toLowerCase();

        // 2a) Fehlende Leerzeichen zwischen Buchstaben und Ziffern aufbrechen,
        //     damit aus "Hennmoor1Horst" -> "Hennmoor 1 Horst" wird.
        //     a) Buchstabe direkt vor Ziffer: "Hennmoor1" -> "Hennmoor 1"
        value = value.replace(/([A-Za-z√Ñ√ñ√ú√§√∂√º√ü])(\d)/g, "$1 $2");
        //     b) Ziffer direkt vor Gro√übuchstabe: "1Horst" -> "1 Horst"
        value = value.replace(/(\d)([A-Za-z√Ñ√ñ√ú√§√∂√º√ü]{2,})/g, "$1 $2");
        lower = value.toLowerCase();

        // 2b) Fehlende Leerzeichen vor "Chaussee": "HeisterenderChaussee" -> "Heisterender Chaussee"
        value = value.replace(/\b([A-Za-z√Ñ√ñ√ú√§√∂√º√ü]+)(chaussee)\b/gi, "$1 $2");

        // 2c) Spezielle Korrektur f√ºr Brande-H√∂rnerkirchen (h√§ufig im Einsatzgebiet)
        //     ohne Bindestrich geschriebene Varianten werden auf die korrekte Schreibweise gebracht.
        value = value.replace(/\bbrandeh√∂rnerkirchen\b/gi, "Brande-H√∂rnerkirchen");
        value = value.replace(/\bbrande h√∂rnerkirchen\b/gi, "Brande-H√∂rnerkirchen");
        value = value.replace(/\bbrandeh√∂rner kirchen\b/gi, "Brande-H√∂rnerkirchen");
        // 2c-erg√§nzend) Weitere h√§ufige Orts-/Stra√üennamen im Einsatzgebiet korrigieren.
        value = value.replace(/\blentf√∂rden\b/gi, "Lentf√∂hrden");
        value = value.replace(/\bjannbeyer\b/gi, "Jannebyer");
        //    Varianten rund um "Holtenauer" vereinheitlichen (h√§ufig verwendet)
        value = value.replace(/\bholtenaer\b/gi, "Holtenauer");
        value = value.replace(/\bholtenaeuer\b/gi, "Holtenauer");
        value = value.replace(/\bholtena√ºr\b/gi, "Holtenauer");
        value = value.replace(/\bholten√§r\b/gi, "Holtenauer");

        // 2c-extra) "Musterstr." am Wortende (z.B. "Hafenstr.", "Bahnhofstr.", "Johann-Fleck-Str.") -> "Musterstra√üe"
        value = value.replace(/([A-Za-z√Ñ√ñ√ú√§√∂√º√ü\-]+)str\./gi, "$1stra√üe");


        // 2d) Umlaute aus ASCII-Ersatzschreibweise (ae, oe) wiederherstellen.
        //     Dies betrifft z.B. "Muenster" -> bleibt unver√§ndert (kein Zwangs-√§ mehr),
        //     aber "Schoenberg" -> "Sch√∂nberg" usw.
        //     WICHTIG: Es findet KEINE automatische Umwandlung von "ue" mehr statt,
        //     damit korrekte Ortsnamen wie "Uetersen" nicht verf√§lscht werden.
        value = value.replace(/ae/gi, (match) => {
            if (match === "ae") return "√§";
            if (match === "AE" || match === "Ae" || match === "aE") return "√Ñ";
            return match;
        });
        value = value.replace(/oe/gi, (match) => {
            if (match === "oe") return "√∂";
            if (match === "OE" || match === "Oe" || match === "oE") return "√ñ";
            return match;
        });
        // KEINE ue->√º-Logik mehr, um Schreibweisen wie "Uetersen" nicht zu zerst√∂ren.


// Hilfsfunktion: ersetze in value anhand eines Regex, aber case-insensitiv auf lower gepr√ºft.
        function replaceWordLike(pattern, replaceFn) {
            // pattern: RegExp, die auf lower gepr√ºft wird, mit gleicher L√§nge wie im Original
            let m;
            let result = "";
            let lastIndex = 0;
            while ((m = pattern.exec(lower)) !== null) {
                const start = m.index;
                const end = start + m[0].length;
                result += value.slice(lastIndex, start);
                result += replaceFn(value.slice(start, end), m);
                lastIndex = end;
            }
            if (lastIndex === 0) {
                return value;
            }
            result += value.slice(lastIndex);
            return result;
        }

        // a) "strasse" -> "stra√üe"
        lower = lower; // ensure defined
        if (/\bstrasse\b/.test(lower)) {
            value = value.replace(/\bstrasse\b/gi, "stra√üe");
            lower = value.toLowerCase();
        }

        // b) getrennte Abk√ºrzungen "str", "str.", "str," usw. als eigenst√§ndiges Wort
        //    F√§lle wie: "Musterstr. 5", "Muster str. 5", "Muster str, 5"
        //    Wir betrachten nur " str" als eigenes Wort, nicht als Teil von z.B. "Strand".
        //    Erst Varianten mit Punkt/Komma:
        value = value.replace(/\bstr\s*\./gi, "stra√üe");
        value = value.replace(/\bstr\s*,/gi, "stra√üe,");
        //    Dann nacktes "str" als Wort:
        value = value.replace(/\bstr\b/gi, "stra√üe");
        //    Nach diesen Ersetzungen erneut Leerzeichen bereinigen:
        value = value.replace(/\s+/g, " ");
        lower = value.toLowerCase();

        // c) "str ." (getrennt) -> "stra√üe "
        value = value.replace(/\bstra√üe\s*\./gi, "stra√üe");

        // 3) Fehlende Leerzeichen vor/um Hausnummern nach "Stra√üe"
        //    Beispiel: "KaltenkirchenerStra√üe17,Hamburg" -> "Kaltenkirchener stra√üe 17,Hamburg"
        // a) Zwischen "stra√üe" und Ziffer eine L√ºcke erzwingen:
        value = value.replace(/stra√üe(\d)/gi, "stra√üe $1");

        // b) Falls ein Wort direkt mit "stra√üe" endet, aber ohne Leerzeichen davor geschrieben wurde
        //    (z.B. "NeueStra√üe 5"), f√ºge zwischen Wort und "stra√üe" ein Leerzeichen ein.
        // c) Ein fehlendes Leerzeichen nach der Hausnummer vor einem Komma erg√§nzen:
        //    "Stra√üe 17,Hamburg" -> "Stra√üe 17, Hamburg"
        value = value.replace(/(\d),\s*(\S)/g, "$1, $2");

        // 3) Hausnummer-Bereiche "3-19" oder "3‚Äì19" je nach Einstellung auf eine Nummer reduzieren.
        //    Gilt nur f√ºr 1‚Äì4-stellige Zahlen, damit PLZ (5-stellig) nicht angefasst werden.
        if (currentSettings.rangeHandling === "first") {
            value = value.replace(/\b(\d{1,4})\s*[-‚Äì]\s*(\d{1,4})\b/g, "$1");
            // auch Schreibweise "26/28" wie einen Bereich behandeln
            value = value.replace(/\b(\d{1,4})\s*\/\s*(\d{1,4})\b/g, "$1");
        } else if (currentSettings.rangeHandling === "last") {
            value = value.replace(/\b(\d{1,4})\s*[-‚Äì]\s*(\d{1,4})\b/g, "$2");
            value = value.replace(/\b(\d{1,4})\s*\/\s*(\d{1,4})\b/g, "$2");
        }

        // 3a) Mehrere Hausnummern in einem Eintrag auf eine f√ºhrende Nummer reduzieren.
        //     "1/1a" -> "1"
        value = value.replace(/\b(\d+)\s*\/\s*\d+[A-Za-z]?\b/g, "$1");
        //     "1 + 1a" -> "1"
        value = value.replace(/\b(\d+)\s*\+\s*\d+[A-Za-z]?\b/g, "$1");
        //     "6 a,b" -> "6"
        value = value.replace(/\b(\d+)\s+[A-Za-z]\s*,\s*[A-Za-z](?:\s*,\s*[A-Za-z])*\b/gi, "$1");
        //     "5a-j" -> "5a"
        value = value.replace(/\b(\d+[A-Za-z])\s*[-‚Äì]\s*[A-Za-z]\b/gi, "$1");
        //     "102, 104" oder "6, 8, 10" -> erste Nummer
        value = value.replace(/\b(\d{1,4})\s*,\s*\d{1,4}(?:\s*,\s*\d{1,4})*\b/g, "$1");

        // 3b) Mehrere Stra√üenz√ºge in einer Zeile: nur den ersten Stra√üenzug behalten.
        //     "Am Markt 8 / Glockengie√üerwall 1" -> "Am Markt 8 ..."
        value = value.replace(/\s+\/\s+[^,\d]+(\d+[A-Za-z]?)?/g, "");
        //     "Lornsenstra√üe 1-5/Vicelinstr.40-44" -> "Lornsenstra√üe 1-5"
        value = value.replace(/(\d[0-9A-Za-z\-]*)\/[A-Za-z√Ñ√ñ√ú√§√∂√º√ü][^,\s]*/g, "$1");
        //     "Marschweg 71/ Ecke Flottkamp" -> "Marschweg 71"
        value = value.replace(/(\d{1,4})\s*\/\s*Ecke\b.*$/gi, "$1");
        // 3b-weiter) Wenn nach einem Komma erneut etwas wie "Stra√üe/Str./Weg/Allee/Ring/Kamp/Chaussee + Hausnummer"
        //             folgt, behandeln wir das als zweiten Stra√üenzug und schneiden ihn ab.
        //             Beispiel: "Noldestra√üe 1-21, Pechsteinstra√üe 1-15" -> "Noldestra√üe 1-21"
        value = value.replace(/,\s*[A-Za-z√Ñ√ñ√ú√§√∂√º√ü][^,\d]*?(stra√üe|str\.|weg|allee|ring|kamp|chaussee)\b[^,]*/gi, "");



        // 3c) Datum-Fragmente aus Excel-Interpretationen in Hausnummern umwandeln.
        //     "Lechweg 01. Jul" -> "Lechweg 1"
        value = value.replace(/\b0?(\d{1,2})\.\s*(Jan|Feb|M√§r|Mrz|Apr|Mai|Jun|Jul|Aug|Sep|Okt|Nov|Dez)\b/gi, "$1");
        //     "Noldestr. Okt 14" -> "Noldestr. 14"
        value = value.replace(/\b(Jan|Feb|M√§r|Mrz|Apr|Mai|Jun|Jul|Aug|Sep|Okt|Nov|Dez)\s+(\d+[A-Za-z]?)\b/gi, "$2");

        // 4) Fehlende Kommas zwischen Stra√üe und Stadt grob erg√§nzen.
        //    Beispiel: "Musterstra√üe 5 Horst" -> "Musterstra√üe 5, Horst"
        //    Wichtig: Nur erg√§nzen, wenn der letzte Token eindeutig wie eine Stadt aussieht
        //    (also KEINE Ziffer enth√§lt), damit Eingaben wie "24568 Sch√ºtzenstra√üe 19"
        //    oder "24568 Sch√ºtzenstra√üe 19 24568" nicht verf√§lscht werden.
        if (value.indexOf(",") === -1) {
            const tokens = value.split(/\s+/).filter(Boolean);
            if (tokens.length >= 3) {
                const cityToken = tokens[tokens.length - 1];
                // Wir suchen eine Struktur: [...irgendwas..., Hausnummer, Stadt]
                // Heuristik: letzter Token ist Stadt (keine Ziffer), mindestens ein Token davor enth√§lt eine Ziffer.
                if (!/\d/.test(cityToken)) {
                    let hasNumberBeforeLast = false;
                    for (let i = 0; i < tokens.length - 1; i++) {
                        if (/\d/.test(tokens[i])) {
                            hasNumberBeforeLast = true;
                            break;
                        }
                    }
                    if (hasNumberBeforeLast) {
                        const streetPart = tokens.slice(0, -1).join(" ");
                        value = streetPart + ", " + cityToken;
                    }
                }
            }
        }

        // 5) Abschlie√üende Bereinigung mehrfacher Leerzeichen
        value = value.replace(/\s+/g, " ").trim();

        return value;
    }

    function cleanAddressLine(line) {
        let cleaned = line.trim();
        if (!cleaned) return "";
        cleaned = cleaned.replace(/[:;]+/g, " ");
        cleaned = cleaned.replace(/\s+/g, " ");
        cleaned = normalizeAddressText(cleaned);
        return cleaned;
    }

    function parseAddresses(rawText) {
        const lines = rawText.split(/\r?\n/);
        const unique = new Set();
        const result = [];
        for (let rawLine of lines) {
            let cleaned = cleanAddressLine(rawLine);
            if (!cleaned) continue;
            const key = cleaned.toLowerCase();
            if (unique.has(key)) continue;
            unique.add(key);
            result.push({
                raw: rawLine,
                cleaned: cleaned,
                display: "",
                lat: null,
                lon: null,
                postcode: "",
                city: "",
                note: "",
                earliest: "",
                latest: "",
                window: "",
                duration: "00:05",
                visitBeforeIndex: "",
                visitAfterIndex: "",
                active: true
            });
        }
        return result;
    }

    function clearMarkers() {
        for (const m of markers) {
            if (m) map.removeLayer(m);
        }
        markers = [];
    }

    function rebuildFaultyAddressesFromStops() {
        faultyAddresses = [];
        for (const stop of stops) {
            if (stop && (stop.lat === null || stop.lon === null)) {
                const addr = stop.cleaned || stop.raw;
                if (addr) {
                    faultyAddresses.push(addr);
                }
            }
        }
    }

    
function updateFaultyButton() {
        const btn = document.getElementById("faultyBtn");
        const navBtn = document.getElementById("faultyNextBtn");
        if (!btn) return;

        if (faultyAddresses.length > 0) {
            btn.style.display = "inline-flex";
            if (navBtn) navBtn.style.display = "inline-flex";
            if (faultyAddresses.length === 1) {
                btn.textContent = "1 fehlerhafte Adresse";
            } else {
                btn.textContent = faultyAddresses.length + " fehlerhafte Adressen";
            }
        } else {
            btn.style.display = "none";
            if (navBtn) navBtn.style.display = "none";
            faultyNavIndex = -1;
        }
    }


    function collectFaultyStopsWithIndex() {
        const result = [];
        for (let i = 0; i < stops.length; i++) {
            const s = stops[i];
            if (s && (s.lat === null || s.lon === null)) {
                const addr = s.cleaned || s.raw;
                if (addr) {
                    result.push({ index: i, address: addr });
                }
            }
        }
        return result;
    }

    function openFaultyWarningModalIfNeeded() {
        const faultyList = collectFaultyStopsWithIndex();
        const count = faultyList.length;
        if (!count) return;

        const backdrop = document.getElementById("faultyWarnModalBackdrop");
        const msgEl = document.getElementById("faultyWarnMessage");
        const listEl = document.getElementById("faultyWarnList");
        if (!backdrop || !msgEl || !listEl) return;

        if (count === 1) {
            msgEl.textContent = "1 Adresse konnte nicht erkannt werden.";
        } else {
            msgEl.textContent = count + " Adressen konnten nicht erkannt werden.";
        }

        listEl.innerHTML = "";
        const info = document.createElement("div");
        info.style.fontSize = "12px";
        info.style.opacity = "0.8";
        info.style.marginBottom = "4px";
        info.textContent = "Klicke auf eine Adresse, um sie direkt im Bearbeiten-Dialog zu √∂ffnen.";
        listEl.appendChild(info);

        const ul = document.createElement("ul");
        ul.style.listStyle = "none";
        ul.style.margin = "0";
        ul.style.padding = "0";

        faultyList.forEach(item => {
            const li = document.createElement("li");
            li.textContent = (item.index + 1) + ". " + item.address;
            li.dataset.stopIndex = String(item.index);
            li.style.cursor = "pointer";
            li.style.padding = "4px 6px";
            li.style.borderRadius = "4px";
            li.style.marginBottom = "2px";
            li.addEventListener("mouseenter", () => {
                li.style.backgroundColor = "rgba(148,163,184,0.15)";
            });
            li.addEventListener("mouseleave", () => {
                li.style.backgroundColor = "transparent";
            });
            li.addEventListener("click", () => {
                if (typeof openStopEditModal === "function") {
                    openStopEditModal(item.index);
                }
            });
            ul.appendChild(li);
        });

        listEl.appendChild(ul);

        const hideCheckbox = document.getElementById("faultyWarnHideResolved");
        if (hideCheckbox) {
            hideCheckbox.checked = false;
        }
        if (typeof updateFaultyWarnResolvedVisibility === "function") {
            updateFaultyWarnResolvedVisibility();
        }

        backdrop.style.display = "flex";
    }

    function closeFaultyWarningModal() {
        const backdrop = document.getElementById("faultyWarnModalBackdrop");
        if (backdrop) {
            backdrop.style.display = "none";
        }
    }

    function markFaultyAddressResolved(index) {
        const backdrop = document.getElementById("faultyWarnModalBackdrop");
        if (!backdrop || backdrop.style.display === "none") return;

        const listEl = document.getElementById("faultyWarnList");
        if (!listEl) return;

        const li = listEl.querySelector('li[data-stop-index="' + index + '"]');
        if (!li) return;

        const s = stops[index];
        if (!s || s.lat === null || s.lon === null) return;

        if (li.dataset.resolved === "1") return;
        li.dataset.resolved = "1";

        const checkSpan = document.createElement("span");
        checkSpan.textContent = " ‚úì";
        checkSpan.style.fontWeight = "bold";
        checkSpan.style.marginLeft = "6px";
        li.appendChild(checkSpan);

        li.style.opacity = "0.6";

        if (typeof updateFaultyWarnResolvedVisibility === "function") {
            updateFaultyWarnResolvedVisibility();
        }
    }

    function updateFaultyWarnResolvedVisibility() {
        const checkbox = document.getElementById("faultyWarnHideResolved");
        const listEl = document.getElementById("faultyWarnList");
        if (!checkbox || !listEl) return;

        const hide = checkbox.checked;
        const items = listEl.querySelectorAll('li[data-stop-index]');
        items.forEach(li => {
            if (li.dataset.resolved === "1" && hide) {
                li.style.display = "none";
            } else {
                li.style.display = "";
            }
        });
    }


    function refreshFaultyWarningModalAfterDataChange() {
        const backdrop = document.getElementById("faultyWarnModalBackdrop");
        if (!backdrop || backdrop.style.display === "none") return;

        const faultyList = collectFaultyStopsWithIndex();
        const count = faultyList.length;

        // Wenn es keine fehlerhaften Adressen mehr gibt, Popup schlie√üen
        if (!count) {
            if (typeof closeFaultyWarningModal === "function") {
                closeFaultyWarningModal();
            }
            return;
        }

        // Sonst Liste im bestehenden Dialog neu aufbauen
        if (typeof openFaultyWarningModalIfNeeded === "function") {
            openFaultyWarningModalIfNeeded();
        }
    }

    function navigateNextFaulty() {
        const faultyIndices = [];
        for (let i = 0; i < stops.length; i++) {
            const s = stops[i];
            if (s && (s.lat === null || s.lon === null)) {
                faultyIndices.push(i);
            }
        }

        if (!faultyIndices.length) {
            setPanelStatus("Derzeit wurden keine fehlerhaften Adressen erkannt.");
            faultyNavIndex = -1;
            updateFaultyButton();
            return;
        }

        if (faultyNavIndex === -1) {
            // Start mit der ersten fehlerhaften Adresse
            faultyNavIndex = faultyIndices[0];
        } else {
            const currentPos = faultyIndices.indexOf(faultyNavIndex);
            if (currentPos === -1 || currentPos === faultyIndices.length - 1) {
                faultyNavIndex = faultyIndices[0];
            } else {
                faultyNavIndex = faultyIndices[currentPos + 1];
            }
        }

        const index = faultyNavIndex;
        highlightStop(index, false);

        const listItems = document.querySelectorAll(".stop-item");
        if (listItems[index]) {
            listItems[index].scrollIntoView({ block: "nearest", behavior: "smooth" });
        }
    }

function openFaultyAddressesInImport() {
        if (!faultyAddresses.length) {
            setPanelStatus("Derzeit wurden keine fehlerhaften Adressen erkannt.");
            return;
        }
        const textarea = document.getElementById("modalAddressInput");
        if (!textarea) return;
        textarea.value = faultyAddresses.join("\n");
        openImportModal();
    }

    
function clearStopList() {
        stops = [];
        const ul = document.getElementById("stopList");
        if (ul) ul.innerHTML = "";
        const bottomList = document.getElementById("bottomRouteList");
        if (bottomList) bottomList.innerHTML = "";
        const panelBody = document.querySelector(".bottom-panel-body");
        if (panelBody) panelBody.style.display = "none";
        const filterInput = document.getElementById("addressFilterInput");
        if (filterInput) filterInput.value = "";
        updateStopCount();
        setPanelStatus("Keine Stopps geladen.");
        setSummary("Gesamt: ‚Äì");
        faultyAddresses = [];
        faultyNavIndex = -1;
        updateFaultyButton();
    }


    function resetAll() {
        clearMarkers();
        clearStopList();
        hideStopMenu();
        if (routeLayer && map) {
            map.removeLayer(routeLayer);
            routeLayer = null;
        }
        if (map) {
            map.setView([51.163375, 10.447683], 6);
        }
    }

    
    
    
function renderBottomRouteSummary() {
        const container = document.getElementById("bottomRouteList");
        if (!container) return;
        container.innerHTML = "";
        const panelBody = document.querySelector(".bottom-panel-body");

        // Routen√ºbersicht nur anzeigen, wenn wirklich eine Route berechnet wurde
        if (!routeComputed || !stops.length) {
            if (panelBody) panelBody.style.display = "none";
            return;
        }

        // Aktive Stopps mit Koordinaten in Reihenfolge der Route bestimmen
        const activeIndices = [];
        for (let i = 0; i < stops.length; i++) {
            const s = stops[i];
            if (s && s.lat !== null && s.lon !== null && s.active !== false) {
                activeIndices.push(i);
            }
        }
        if (!activeIndices.length) {
            if (panelBody) panelBody.style.display = "none";
            return;
        }

        if (panelBody) panelBody.style.display = "block";

        activeIndices.forEach((stopIndex, pos) => {
            const stop = stops[stopIndex];
            const row = document.createElement("div");
            row.className = "bottom-route-row";

            const idxSpan = document.createElement("span");
            idxSpan.className = "bottom-route-index";
            idxSpan.textContent = (pos + 1) + ".";

            const metaSpan = document.createElement("span");
            metaSpan.className = "bottom-route-meta";
            if (pos === 0) {
                metaSpan.textContent = "Startpunkt";
            } else if (stop.fromPrevDistanceText && stop.fromPrevDurationText) {
                metaSpan.textContent = stop.fromPrevDistanceText + " ¬∑ " + stop.fromPrevDurationText;
            } else {
                metaSpan.textContent = "Verbindung wird berechnet ‚Ä¶";
            }

            const addrSpan = document.createElement("span");
            addrSpan.className = "bottom-route-address";
            const displayAddress = stop.display || stop.cleaned;
            addrSpan.textContent = displayAddress;

            row.appendChild(idxSpan);
            row.appendChild(metaSpan);
            row.appendChild(addrSpan);

            row.addEventListener("click", () => highlightStop(stopIndex, true));

            container.appendChild(row);
        });

        const summaryEl = document.getElementById("bottomSummaryInfo");
        if (summaryEl && summaryEl.textContent && summaryEl.textContent.trim() !== "") {
            const sumDiv = document.createElement("div");
            sumDiv.className = "bottom-route-summary-line";
            sumDiv.textContent = summaryEl.textContent;
            container.appendChild(sumDiv);
        }
    }




function renderStopList() {
        const ul = document.getElementById("stopList");
        if (!ul) return;
        ul.innerHTML = "";

        const filterInput = document.getElementById("addressFilterInput");
        const filterValue = filterInput ? filterInput.value.trim().toLowerCase() : "";
        let visibleCount = 0;

        // Reihenfolge: zuerst aktive, dann inaktive Stopps (Anzeige im Panel)
        const activeIndices = [];
        const inactiveIndices = [];
        stops.forEach((s, idx) => {
            if (s && s.active === false) inactiveIndices.push(idx);
            else activeIndices.push(idx);
        });
        const orderedIndices = activeIndices.concat(inactiveIndices);

        orderedIndices.forEach((index) => {
            const stop = stops[index];
            if (!stop) return;

            const displayAddressText = stop.display || stop.cleaned || "";
            const haystack = (
                displayAddressText + " " +
                (stop.postcode || "") + " " +
                (stop.city || "") + " " +
                (stop.note || "")
            ).toLowerCase();

            if (filterValue && !haystack.includes(filterValue)) {
                return;
            }

            const li = document.createElement("li");
            li.className = "stop-item";
            li.dataset.index = index;
            li.setAttribute("draggable", "true");
            if (index === activeIndex) li.classList.add("active");
            if (stop.active === false) li.classList.add("inactive");

            const indexBadge = document.createElement("div");
            indexBadge.className = "stop-index";
            indexBadge.textContent = index + 1;

            const main = document.createElement("div");
            main.className = "stop-main";

            const addr = document.createElement("div");
            addr.className = "stop-address";
            addr.textContent = displayAddressText;
            li.title = displayAddressText;

            const meta = document.createElement("div");
            meta.className = "stop-meta";
            const isActive = stop.active !== false && stop.lat !== null && stop.lon !== null;
            if (stop.active === false) {
                meta.textContent = "Inaktiv ‚Äì wird in Route und Druck ignoriert";
            } else if (index === 0) {
                meta.textContent = "Startpunkt (aktuelle Reihenfolge)";
            } else if (stop.fromPrevDistanceText && stop.fromPrevDurationText && isActive) {
                meta.textContent = "‚Üí " + stop.fromPrevDistanceText + " ¬∑ " + stop.fromPrevDurationText;
            } else {
                meta.textContent = "Verbindung wird berechnet ‚Ä¶";
            }

            main.appendChild(addr);
            main.appendChild(meta);
            li.appendChild(indexBadge);
            li.appendChild(main);

            li.addEventListener("click", () => highlightStop(index, true));
            li.addEventListener("dragstart", handleDragStart);
            li.addEventListener("dragover", handleDragOver);
            li.addEventListener("dragleave", handleDragLeave);
            li.addEventListener("drop", handleDrop);
            li.addEventListener("dragend", handleDragEnd);

            ul.appendChild(li);
            visibleCount++;
        });
        updateStopCount();
        if (stops.length) {
            if (filterValue) {
                setPanelStatus("Gefiltert: " + visibleCount + " von " + stops.length + " Stopps");
            } else {
                setPanelStatus("Stopps geladen. Ziehen zum Umordnen, Klick f√ºr Aktionen.");
            }
        }
    }




function highlightStop(index, openMenu) {
        activeIndex = index;
        const listItems = document.querySelectorAll(".stop-item");
        listItems.forEach((item) => {
            const itemIndex = Number(item.dataset.index);
            if (itemIndex === index) item.classList.add("active");
            else item.classList.remove("active");
        });

        markers.forEach((m, i) => {
            if (m && m._icon) {
                if (i === index) m._icon.classList.add("stop-marker-active");
                else m._icon.classList.remove("stop-marker-active");
            }
        });

        const marker = markers[index];
        if (marker && map) {
            map.panTo(marker.getLatLng());
            if (openMenu) {
                showStopMenu(index, marker.getLatLng());
            }
        } else if (openMenu) {
            // Kein Marker vorhanden (z.B. fehlerhafte Adresse) -> direkt bearbeiten erm√∂glichen
            openStopEditModal(index);
        }
    }



function createMarkerIcon(index) {
        const stop = stops[index];
        let cls = "stop-marker ";
        let html = "";

        // Bestimmen, ob dieser Stopp aktuell f√ºr die Route aktiv ist
        const isActive = stop && stop.lat !== null && stop.lon !== null && stop.active !== false;

        // Alle aktiven Stopps mit Koordinaten sammeln, um Start/Ende und Positionsnummer zu berechnen
        const activeIndices = [];
        for (let i = 0; i < stops.length; i++) {
            const s = stops[i];
            if (s && s.lat !== null && s.lon !== null && s.active !== false) {
                activeIndices.push(i);
            }
        }

        if (!isActive) {
            // Inaktive oder ung√ºltige Stopps als neutrale Marker darstellen
            cls += "stop-marker-mid stop-marker-inactive";
            html = "";
        } else {
            const totalActive = activeIndices.length;
            const posInActive = activeIndices.indexOf(index);

            if (posInActive === 0) {
                cls += "stop-marker-start";
                html = "üè†";
            } else if (posInActive === totalActive - 1) {
                cls += "stop-marker-end";
                html = "üèÅ";
            } else {
                cls += "stop-marker-mid";
                html = String(posInActive + 1);
            }
        }

        return L.divIcon({
            className: cls + " leaflet-div-icon",
            html: html,
            iconSize: [28, 28],
            iconAnchor: [14, 14]
        });
    }

    
    function updateMarkerLabels() {
        markers.forEach((m, idx) => {
            if (m) {
                const icon = createMarkerIcon(idx);
                m.setIcon(icon);
                m._stopIndex = idx;
            }
        });
    }

    function setRouteLoading(isLoading) {
        const el = document.getElementById("routeLoadingIndicator");
        if (!el) return;
        el.style.display = isLoading ? "inline-flex" : "none";
    }

    
    // Entfernungsberechnung (Luftlinie) in Kilometern
    function haversineDistanceKm(lat1, lon1, lat2, lon2) {
        const R = 6371; // Erdradius in km
        const toRad = Math.PI / 180;
        const dLat = (lat2 - lat1) * toRad;
        const dLon = (lon2 - lon1) * toRad;
        const a =
            Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos(lat1 * toRad) * Math.cos(lat2 * toRad) *
            Math.sin(dLon / 2) * Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
    }

    // Einfache Routenoptimierung:
    // - Start = erster aktiver/geokodierter Stopp
    // - Ziel  = letzter aktiver/geokodierter Stopp
    // - Dazwischen: Nearest-Neighbor + 2-Opt-Verbesserung
    // Die Optimierung wird nur ausgef√ºhrt, wenn
    //   3 <= aktive Stopps <= OPTIMIZATION_MAX_ACTIVE_STOPS
    function optimizeStopsOrderIfNeeded() {
        if (!stops || stops.length < 3) return;

        // Alle aktiven und geokodierten Stopps einsammeln
        const locIndices = [];
        for (let i = 0; i < stops.length; i++) {
            const s = stops[i];
            if (!s) continue;
            if (s.lat === null || s.lon === null) continue;
            if (s.active === false) continue;
            locIndices.push(i);
        }

        if (locIndices.length < 3) {
            return;
        }

        if (locIndices.length > OPTIMIZATION_MAX_ACTIVE_STOPS) {
            // Zu viele Stopps ‚Äì Route wird in Eingabereihenfolge berechnet
            setPanelStatus(
                "Zu viele Stopps f√ºr automatische Optimierung (" +
                locIndices.length +
                " > " +
                OPTIMIZATION_MAX_ACTIVE_STOPS +
                "). Route wird in eingegebener Reihenfolge berechnet."
            );
            return;
        }

        const startIdx = locIndices[0];
        const endIdx = locIndices[locIndices.length - 1];
        const middle = locIndices.slice(1, locIndices.length - 1);

        if (!middle.length) {
            return; // Nur Start und Ziel, nichts zu optimieren
        }

        function getPoint(idx) {
            const s = stops[idx];
            if (!s || s.lat === null || s.lon === null) return null;
            return [s.lat, s.lon];
        }

        // Nearest-Neighbor-Heuristik f√ºr die Zwischenstopps
        const order = [startIdx];
        let currentIdx = startIdx;
        const remaining = middle.slice();

        while (remaining.length > 0) {
            let bestPos = 0;
            let bestIdx = remaining[0];
            let bestDist = Infinity;

            const currentPt = getPoint(currentIdx);
            if (!currentPt) break;
            const [clat, clon] = currentPt;

            for (let i = 0; i < remaining.length; i++) {
                const candIdx = remaining[i];
                const pt = getPoint(candIdx);
                if (!pt) continue;
                const d = haversineDistanceKm(clat, clon, pt[0], pt[1]);
                if (d < bestDist) {
                    bestDist = d;
                    bestIdx = candIdx;
                    bestPos = i;
                }
            }

            order.push(bestIdx);
            currentIdx = bestIdx;
            remaining.splice(bestPos, 1);
        }

        // Ziel anh√§ngen
        order.push(endIdx);

        // 2-Opt-Verbesserung (Start/Ziel fix)
        function totalLengthKm(routeOrder) {
            let sum = 0;
            for (let i = 0; i < routeOrder.length - 1; i++) {
                const p1 = getPoint(routeOrder[i]);
                const p2 = getPoint(routeOrder[i + 1]);
                if (!p1 || !p2) continue;
                sum += haversineDistanceKm(p1[0], p1[1], p2[0], p2[1]);
            }
            return sum;
        }

        let bestOrder = order.slice();
        let bestLen = totalLengthKm(bestOrder);
        let improved = true;
        let guard = 0;
        const n = bestOrder.length;

        while (improved && guard < 4) {
            improved = false;
            guard++;
            for (let i = 1; i < n - 2; i++) {
                for (let k = i + 1; k < n - 1; k++) {
                    const newOrder = bestOrder.slice();
                    const segment = newOrder.slice(i, k + 1).reverse();
                    newOrder.splice(i, segment.length, ...segment);
                    const newLen = totalLengthKm(newOrder);
                    if (newLen + 1e-6 < bestLen) {
                        bestLen = newLen;
                        bestOrder = newOrder;
                        improved = true;
                    }
                }
            }
        }

        // Neue Reihenfolge anwenden:
        // Zuerst alle optimierten Stopps, dann die √ºbrigen (nicht geokodiert / inaktiv)
        const used = new Set(bestOrder);
        const newStops = [];
        const newMarkers = [];

        for (let idx of bestOrder) {
            newStops.push(stops[idx]);
            newMarkers.push(markers[idx]);
        }
        for (let i = 0; i < stops.length; i++) {
            if (!used.has(i)) {
                newStops.push(stops[i]);
                newMarkers.push(markers[i]);
            }
        }

        stops = newStops;
        markers = newMarkers;

        updateMarkerLabels();
        renderStopList();

        setPanelStatus(
            "Optimierung angewendet (" + locIndices.length + " Stopps)."
        );
    }


    // Lokale Re-Optimierung der Route nach einer manuellen Verschiebung (Drag & Drop).
    // Der Stopp mit Index anchorStopIndex (im stops-Array VOR der Optimierung) bleibt
    // im aktiven Teil der Route an seiner Position (in der aktiven Reihenfolge) fix,
    // die Stopps dahinter werden mit derselben Heuristik wie bei der globalen Optimierung
    // (Nearest-Neighbor + 2-Opt, Start/Ziel fix) neu angeordnet.
    //
    // R√ºckgabewert: true, wenn eine Optimierung durchgef√ºhrt wurde, sonst false.
    function reoptimizeRouteWithAnchor(anchorStopIndex) {
        if (!stops || stops.length < 3) return false;
        if (anchorStopIndex == null || anchorStopIndex < 0 || anchorStopIndex >= stops.length) {
            return false;
        }

        // Alle aktiven und geokodierten Stopps einsammeln
        const locIndices = [];
        for (let i = 0; i < stops.length; i++) {
            const s = stops[i];
            if (!s) continue;
            if (s.lat === null || s.lon === null) continue;
            if (s.active === false) continue;
            locIndices.push(i);
        }

        if (locIndices.length < 3) {
            return false;
        }

        if (locIndices.length > OPTIMIZATION_MAX_ACTIVE_STOPS) {
            // Zu viele Stopps ‚Äì f√ºr sehr gro√üe Routen keine zus√§tzliche Optimierung beim Drag & Drop.
            return false;
        }

        const anchorPos = locIndices.indexOf(anchorStopIndex);
        if (anchorPos === -1) {
            // Der verschobene Stopp geh√∂rt nicht zum aktiven/geokodierten Teil der Route.
            return false;
        }
        if (anchorPos === locIndices.length - 1) {
            // Der verschobene Stopp ist der letzte aktive Stopp ‚Äì dahinter gibt es nichts zu optimieren.
            return false;
        }

        // Prefix (vor dem Anker) bleibt in seiner Reihenfolge vollst√§ndig erhalten.
        const prefix = locIndices.slice(0, anchorPos);
        // Suffix (ab Anker inklusive letzter Stopp) wird neu optimiert.
        const suffix = locIndices.slice(anchorPos);
        if (suffix.length < 3) {
            // Nur Anker + Endstopp oder weniger ‚Äì hier lohnt keine Optimierung.
            return false;
        }

        const startIdx = suffix[0];
        const endIdx = suffix[suffix.length - 1];
        const middle = suffix.slice(1, -1);

        function getPoint(idx) {
            const s = stops[idx];
            if (!s || s.lat === null || s.lon === null) return null;
            return [s.lat, s.lon];
        }

        // Nearest-Neighbor-Heuristik f√ºr die Zwischenstopps des Suffixes
        const order = [startIdx];
        let currentIdx = startIdx;
        const remaining = middle.slice();

        while (remaining.length > 0) {
            let bestPos = 0;
            let bestIdx = remaining[0];
            let bestDist = Infinity;

            const currentPt = getPoint(currentIdx);
            if (!currentPt) break;
            const [clat, clon] = currentPt;

            for (let i = 0; i < remaining.length; i++) {
                const candIdx = remaining[i];
                const pt = getPoint(candIdx);
                if (!pt) continue;
                const d = haversineDistanceKm(clat, clon, pt[0], pt[1]);
                if (d < bestDist) {
                    bestDist = d;
                    bestIdx = candIdx;
                    bestPos = i;
                }
            }

            order.push(bestIdx);
            currentIdx = bestIdx;
            remaining.splice(bestPos, 1);
        }

        // Ziel anh√§ngen
        order.push(endIdx);

        // 2-Opt-Verbesserung (Start/Ziel des Suffixes fix)
        function totalLengthKm(routeOrder) {
            let sum = 0;
            for (let i = 0; i < routeOrder.length - 1; i++) {
                const p1 = getPoint(routeOrder[i]);
                const p2 = getPoint(routeOrder[i + 1]);
                if (!p1 || !p2) continue;
                sum += haversineDistanceKm(p1[0], p1[1], p2[0], p2[1]);
            }
            return sum;
        }

        let bestOrderSuffix = order.slice();
        let bestLen = totalLengthKm(bestOrderSuffix);
        let improved = true;
        let guard = 0;
        const n = bestOrderSuffix.length;

        while (improved && guard < 10) {
            improved = false;
            guard++;
            for (let i = 1; i < n - 2; i++) {
                for (let k = i + 1; k < n - 1; k++) {
                    const newOrder = bestOrderSuffix.slice();
                    const segment = newOrder.slice(i, k + 1).reverse();
                    newOrder.splice(i, segment.length, ...segment);
                    const newLen = totalLengthKm(newOrder);
                    if (newLen + 1e-6 < bestLen) {
                        bestLen = newLen;
                        bestOrderSuffix = newOrder;
                        improved = true;
                    }
                }
            }
        }

        // Neue Reihenfolge anwenden:
        // 1. prefix (unver√§ndert)
        // 2. optimierter Suffix-Teil (inkl. Anker & Endstopp)
        // 3. alle √ºbrigen Stopps (nicht geokodiert / inaktiv) unver√§ndert anh√§ngen
        const used = new Set();
        const newStops = [];
        const newMarkers = [];

        for (let idx of prefix) {
            used.add(idx);
            newStops.push(stops[idx]);
            newMarkers.push(markers[idx]);
        }
        for (let idx of bestOrderSuffix) {
            used.add(idx);
            newStops.push(stops[idx]);
            newMarkers.push(markers[idx]);
        }
        for (let i = 0; i < stops.length; i++) {
            if (!used.has(i)) {
                newStops.push(stops[i]);
                newMarkers.push(markers[i]);
            }
        }

        stops = newStops;
        markers = newMarkers;

        updateMarkerLabels();
        renderStopList();

        return true;
    }

function buildRouteFromLocations(options) {
        const opts = options || {};
        const skipOptimization = !!opts.skipOptimization;

        if (!stops.length) {
            setSummary("Gesamt: ‚Äì");
            return;
        }

        // Vor der Routenberechnung die Stoppreihenfolge optimieren (Standard)
        if (!skipOptimization) {
            optimizeStopsOrderIfNeeded();
        }

        const locStops = stops.filter(s => s.lat !== null && s.lon !== null && s.active !== false);
        if (locStops.length < 2) {
            setSummary("Gesamt: ‚Äì (mind. 2 g√ºltige Stopps n√∂tig)");
            return;
        }

        const coords = locStops.map(s => s.lon + "," + s.lat).join(";");
        const url = "https://router.project-osrm.org/route/v1/driving/" + coords +
            "?overview=full&geometries=geojson";

        routeComputed = false;
        setRouteLoading(true);
        setPanelStatus("Berechne Route ‚Ä¶");

        fetch(url)
            .then(r => r.json())
            .then(data => {
                if (!data.routes || !data.routes.length) {
                    console.warn("OSRM: keine Route gefunden");
                    if (routeLayer && map) {
                        map.removeLayer(routeLayer);
                        routeLayer = null;
                    }
                    setSummary("Gesamt: ‚Äì (Routenberechnung nicht m√∂glich)");
                    setPanelStatus("Routenberechnung nicht m√∂glich.");
                    return;
                }
                const route = data.routes[0];
                const legs = route.legs || [];

                stops.forEach(s => {
                    s.fromPrevDistanceText = null;
                    s.fromPrevDurationText = null;
                });

                let totalMeters = 0;
                let totalSeconds = 0;

                let legIndex = 0;
                legs.forEach(leg => {
                    totalMeters += leg.distance;
                    totalSeconds += leg.duration;
                    if (legIndex + 1 < locStops.length) {
                        const s = locStops[legIndex + 1];
                        const legKm = leg.distance / 1000;
                        const legMin = Math.round(leg.duration / 60);
                        let legTimeText = "";
                        if (legMin >= 60) {
                            const h = Math.floor(legMin / 60);
                            const m = legMin % 60;
                            legTimeText = h + " Std " + m + " Min";
                        } else {
                            legTimeText = legMin + " Min";
                        }
                        s.fromPrevDistanceText = legKm.toFixed(1) + " km";
                        s.fromPrevDurationText = legTimeText;
                        legIndex++;
                    }
                });

                renderStopList();
                routeComputed = true;
                renderBottomRouteSummary();

                const totalKm = totalMeters / 1000;
                const totalMin = Math.round(totalSeconds / 60);
                const hours = Math.floor(totalMin / 60);
                const mins = totalMin % 60;
                let timeText = "";
                if (hours > 0) timeText += hours + " Std ";
                timeText += mins + " Min";
                setSummary("Gesamt: " + totalKm.toFixed(1) + " km ¬∑ ca. " + timeText);

                if (routeLayer && map) {
                    map.removeLayer(routeLayer);
                    routeLayer = null;
                }
                routeLayer = L.geoJSON(route.geometry, {style: {color: '#ef4444', weight: 5, opacity: 0.9}}).addTo(map);
                map.fitBounds(routeLayer.getBounds(), { padding: [40, 40] });

                setPanelStatus("Route berechnet.");
            })
            .catch(err => {
                console.error("OSRM-Fehler:", err);
                if (routeLayer && map) {
                    map.removeLayer(routeLayer);
                    routeLayer = null;
                }
                setSummary("Gesamt: ‚Äì (Routenberechnung nicht m√∂glich)");
                setPanelStatus("Routenberechnung nicht m√∂glich.");
            })
            .finally(() => {
                setRouteLoading(false);
            });
    }

    function focusAllStopsOnMap() {
        if (!map || !stops || !stops.length) return;

        let bounds = null;
        stops.forEach((stop) => {
            if (stop && stop.lat !== null && stop.lon !== null) {
                const latlng = L.latLng(stop.lat, stop.lon);
                if (!bounds) {
                    bounds = L.latLngBounds(latlng, latlng);
                } else {
                    bounds.extend(latlng);
                }
            }
        });

        if (!bounds) {
            setPanelStatus("Keine g√ºltigen Koordinaten f√ºr eine Kartenausrichtung vorhanden.");
            return;
        }

        let paddingTopLeft = [40, 40];
        let paddingBottomRight = [40, 40];
        const panel = document.getElementById("addressesPanel");
        if (panel && map) {
            const panelWidth = panel.offsetWidth || 0;
            paddingBottomRight = [40 + panelWidth, 40];
        }

        map.fitBounds(bounds, {
            paddingTopLeft: paddingTopLeft,
            paddingBottomRight: paddingBottomRight
        });
    }




function buildDisplayAddress(cleaned, nominatimObj) {
        if (!nominatimObj || !nominatimObj.address) return cleaned;
        const addr = nominatimObj.address || {};
        const postcode = addr.postcode || "";
        const city = addr.city || addr.town || addr.village || addr.hamlet || "";
        const extras = [];
        if (postcode && cleaned.indexOf(postcode) === -1) {
            extras.push(postcode);
        }
        if (city) {
            const cityNorm = city.replace(/\s+/g, " ").trim();
            if (cityNorm && cleaned.toLowerCase().indexOf(cityNorm.toLowerCase()) === -1) {
                extras.push(cityNorm);
            }
        }
        if (!extras.length) return cleaned;
        return cleaned + ", " + extras.join(" ");
    }

function geocodeStopsSequential(addresses, startIndex = 0, isAppend = false) {
        const appending = isAppend && stops && stops.length > 0;

        if (!appending) {
            // Neue Route: alles zur√ºcksetzen
            clearMarkers();
            if (routeLayer && map) {
                map.removeLayer(routeLayer);
                routeLayer = null;
            }
        } else {
            // Bestehende Route wird erweitert: vorhandene Marker bleiben,
            // aber eine evtl. vorhandene Route wird entfernt
            if (routeLayer && map) {
                map.removeLayer(routeLayer);
                routeLayer = null;
            }
        }

        // Sicherstellen, dass jede Adresse sinnvolle Standard-Felder besitzt
        stops = addresses.map(s => {
            if (!s) return s;
            if (typeof s.active === "undefined") {
                s.active = true;
            }
            if (typeof s.display === "undefined") {
                s.display = "";
            }
            if (typeof s.postcode === "undefined") {
                s.postcode = "";
            }
            if (typeof s.city === "undefined") {
                s.city = "";
            }
            return s;
        });
        setSummary("Gesamt: ‚Äì");
        renderStopList();

        if (!addresses.length || startIndex >= stops.length) {
            setPanelStatus("Keine g√ºltigen Adressen gefunden.");
            rebuildFaultyAddressesFromStops();
            updateFaultyButton();
            if (typeof refreshFaultyWarningModalAfterDataChange === "function") {
                refreshFaultyWarningModalAfterDataChange();
            }
            return;
        }

        let idx = appending ? startIndex : 0;
        let bounds = null;

        function next() {
            if (idx >= stops.length) {
                if (bounds && map) {
                    map.fitBounds(bounds, { padding: [40, 40] });
                }
                // Nur Geokodierung abschlie√üen, noch keine Route berechnen
                routeComputed = false;
                const panelBody = document.querySelector(".bottom-panel-body");
                const bottomList = document.getElementById("bottomRouteList");
                if (panelBody) panelBody.style.display = "none";
                if (bottomList) bottomList.innerHTML = "";
                updateMarkerLabels();
                renderStopList();
                rebuildFaultyAddressesFromStops();
                updateFaultyButton();
                openFaultyWarningModalIfNeeded();
                setPanelStatus("Alle Stopps geokodiert. W√§hle Start/Ziel und klicke unten auf 'Route berechnen'.");
                return;
            }
            const stop = stops[idx];
            const addr = stop.cleaned;
            setPanelStatus("Geokodiere Stopp " + (idx + 1) + " von " + stops.length + " ‚Ä¶");

            const url = "https://nominatim.openstreetmap.org/search?format=jsonv2&addressdetails=1&limit=1&q=" +
                encodeURIComponent(addr);

            fetch(url, {
                headers: {
                    "Accept-Language": "de"
                }
            })
                .then(r => r.json())
                .then(data => {
                    if (data && data.length) {
                        // Adresse mit PLZ/Ort anreichern
                        stop.display = buildDisplayAddress(stop.cleaned, data[0]);

                        const addr = data[0].address || {};
                        stop.postcode = addr.postcode || "";
                        stop.city = addr.city || addr.town || addr.village || addr.hamlet || "";

                        const lat = parseFloat(data[0].lat);
                        const lon = parseFloat(data[0].lon);
                        stop.lat = lat;
                        stop.lon = lon;

                        const icon = createMarkerIcon(idx);

                        const marker = L.marker([lat, lon], { icon: icon });
                        marker._stopIndex = idx;
                        marker.on("click", function() {
                            const i = this._stopIndex;
                            highlightStop(i, true);
                        });
                        const tooltipAddress = stop.display || stop.cleaned;
                        marker.bindTooltip(tooltipAddress, {direction: "top", offset: [0, -4], opacity: 0.95, className: "stop-tooltip", sticky: true});
                        marker.addTo(map);
                        markers.push(marker);

                        if (!bounds) {
                            bounds = L.latLngBounds([lat, lon], [lat, lon]);
                        } else {
                            bounds.extend([lat, lon]);
                        }
                    } else {
                        console.warn("Nominatim: nichts gefunden f√ºr", addr);
                        stop.lat = null;
                        stop.lon = null;
                        markers.push(null);
                    }
                })
                .catch(err => {
                    console.error("Nominatim-Fehler f√ºr", addr, err);
                    stop.lat = null;
                    stop.lon = null;
                    markers.push(null);
                })
                .finally(() => {
                    idx++;
                    setTimeout(next, 400);
                });
        }
        next();
    }

    function geocodeSingleStop(index, callback) {
        const stop = stops[index];
        if (!stop || !stop.cleaned) {
            if (callback) callback();
            return;
        }
        setPanelStatus("Geokodiere Stopp " + (index + 1) + " ‚Ä¶");
        const url = "https://nominatim.openstreetmap.org/search?format=jsonv2&addressdetails=1&limit=1&q=" +
            encodeURIComponent(stop.cleaned);

        fetch(url, { headers: { "Accept-Language": "de" } })
            .then(r => r.json())
            .then(data => {
                if (data && data.length) {
                    // Adresse mit PLZ/Ort anreichern
                    stop.display = buildDisplayAddress(stop.cleaned, data[0]);

                    // Postleitzahl und Ort separat speichern (kann sp√§ter z.B. f√ºr Filter genutzt werden)
                    const addr = data[0].address || {};
                    stop.postcode = addr.postcode || "";
                    stop.city = addr.city || addr.town || addr.village || addr.hamlet || "";

                    const lat = parseFloat(data[0].lat);
                    const lon = parseFloat(data[0].lon);
                    stop.lat = lat;
                    stop.lon = lon;

                    const icon = createMarkerIcon(index);

                    let marker = markers[index];
                    if (marker) {
                        marker.setLatLng([lat, lon]);
                        marker.setIcon(icon);
                    } else {
                        marker = L.marker([lat, lon], { icon: icon });
                        marker._stopIndex = index;
                        marker.on("click", function() {
                            const i = this._stopIndex;
                            highlightStop(i, true);
                        });
                        markers[index] = marker;
                    }
                    const tooltipAddress = stop.display || stop.cleaned;
                    marker.bindTooltip(tooltipAddress, {direction: "top", offset: [0, -4], opacity: 0.95, className: "stop-tooltip", sticky: true});
                    if (!map.hasLayer(marker)) {
                        marker.addTo(map);
                    }
                    updateMarkerLabels();
                    // Route wird nicht automatisch neu berechnet.
                    setPanelStatus("Stopp " + (index + 1) + " aktualisiert. Klicke unten auf 'Route berechnen'.");
                } else {
                    console.warn("Nominatim: nichts gefunden f√ºr", stop.cleaned);
                    stop.lat = null;
                    stop.lon = null;
                    setPanelStatus("Adresse konnte nicht gefunden werden.");
                }
            })
            .catch(err => {
                console.error("Nominatim-Fehler f√ºr", stop.cleaned, err);
            })
            .finally(() => {
                rebuildFaultyAddressesFromStops();
                updateFaultyButton();
                markFaultyAddressResolved(index);
                if (callback) callback();
            });
    }

    function openImportModal() {
        document.getElementById("importModalBackdrop").style.display = "flex";
        document.getElementById("modalAddressInput").focus();
    }
    function closeImportModal() {
        document.getElementById("importModalBackdrop").style.display = "none";
    }

    function handleImportFromModal() {
        const raw = document.getElementById("modalAddressInput").value;
        const parsed = parseAddresses(raw);
        if (!parsed.length) {
            setPanelStatus("Bitte gib mindestens eine g√ºltige Adresse ein.");
            closeImportModal();
            return;
        }
        closeImportModal();

        // Wenn noch keine Stopps existieren, neue Route anlegen
        if (!stops || !stops.length) {
            setPanelStatus(parsed.length + " Stopps bereinigt. Geocoding l√§uft ‚Ä¶");
            geocodeStopsSequential(parsed, 0, false);
        } else {
            // Bestehende Route erweitern
            const startIndex = stops.length;
            const combined = stops.concat(parsed);
            setPanelStatus(parsed.length + " weitere Stopps bereinigt. Geocoding l√§uft ‚Ä¶");
            geocodeStopsSequential(combined, startIndex, true);
        }
    }

      let dragSrcIndex = null;

    function handleDragStart(e) {
        dragSrcIndex = Number(this.dataset.index);
        e.dataTransfer.effectAllowed = "move";
        e.dataTransfer.setData("text/plain", String(dragSrcIndex));
        this.classList.add("dragging");
    }

    
    function handleDragOver(e) {
        e.preventDefault();
        if (!this.classList.contains("stop-item")) return;

        // Bisherige Drag-Markierungen zur√ºcksetzen
        document.querySelectorAll(".stop-item.drag-over, .stop-item.drag-over-top, .stop-item.drag-over-bottom")
            .forEach(el => el.classList.remove("drag-over", "drag-over-top", "drag-over-bottom"));

        const rect = this.getBoundingClientRect();
        const offsetY = e.clientY - rect.top;
        const insertBefore = offsetY < rect.height / 2;

        this.classList.add("drag-over");
        if (insertBefore) {
            this.classList.add("drag-over-top");
        } else {
            this.classList.add("drag-over-bottom");
        }

        if (e.dataTransfer) {
            e.dataTransfer.dropEffect = "move";
        }
    }


    
    function handleDragLeave(e) {
        this.classList.remove("drag-over", "drag-over-top", "drag-over-bottom");
    }


    function moveStop(fromIndex, toIndex) {
        if (fromIndex === toIndex) return;
        const movedStop = stops.splice(fromIndex, 1)[0];
        const movedMarker = markers.splice(fromIndex, 1)[0];
        stops.splice(toIndex, 0, movedStop);
        markers.splice(toIndex, 0, movedMarker);
        updateMarkerLabels();
        renderStopList();
        // Falls bereits eine Route existiert, wird rund um den verschobenen Stopp lokal neu optimiert.
        rerouteAfterManualReorder(toIndex);
        hideStopMenu();
    }

    
    function handleDrop(e) {
        e.preventDefault();

        const srcIndex = dragSrcIndex;
        const destIndexRaw = Number(this.dataset.index);

        // Sicherheits-Check
        if (srcIndex === null || Number.isNaN(destIndexRaw) || srcIndex === destIndexRaw) {
            document.querySelectorAll(".stop-item.drag-over, .stop-item.drag-over-top, .stop-item.drag-over-bottom")
                .forEach(el => el.classList.remove("drag-over", "drag-over-top", "drag-over-bottom"));
            dragSrcIndex = null;
            return;
        }

        const rect = this.getBoundingClientRect();
        const offsetY = e.clientY - rect.top;
        const insertBefore = offsetY < rect.height / 2;

        const length = stops.length;
        if (!length) {
            dragSrcIndex = null;
            return;
        }

        // Neue Reihenfolge der Indizes auf Basis der aktuellen Liste berechnen
        const order = [];
        for (let i = 0; i < length; i++) order.push(i);

        // Quellindex aus der aktuellen Reihenfolge entfernen
        const srcPos = order.indexOf(srcIndex);
        if (srcPos === -1) {
            dragSrcIndex = null;
            return;
        }
        order.splice(srcPos, 1);

        // Zielposition in der verbleibenden Liste finden
        let targetPos = order.indexOf(destIndexRaw);
        if (targetPos === -1) {
            targetPos = order.length;
        }

        let insertPos = insertBefore ? targetPos : targetPos + 1;
        if (insertPos < 0) insertPos = 0;
        if (insertPos > order.length) insertPos = order.length;

        order.splice(insertPos, 0, srcIndex);

        // Neue Arrays f√ºr Stops und Marker in dieser Reihenfolge aufbauen
        const newStops = order.map(i => stops[i]);
        const newMarkers = order.map(i => markers[i]);
        stops = newStops;
        markers = newMarkers;

        updateMarkerLabels();
        renderStopList();
        // Falls bereits eine Route existiert, wird rund um den verschobenen Stopp lokal neu optimiert.
        rerouteAfterManualReorder(insertPos);
        hideStopMenu();

        document.querySelectorAll(".stop-item.drag-over, .stop-item.drag-over-top, .stop-item.drag-over-bottom")
            .forEach(el => el.classList.remove("drag-over", "drag-over-top", "drag-over-bottom"));
        dragSrcIndex = null;
    }


    
    function handleDragEnd(e) {
        const items = document.querySelectorAll(".stop-item");
        items.forEach(i => i.classList.remove("drag-over", "drag-over-top", "drag-over-bottom", "dragging"));
        dragSrcIndex = null;
    }


    

    

function handlePrint() {
    // Variante C+ : statische Canvas-Grafik mit OSM-Kartenkacheln im Hintergrund
    if (!stops.length) {
        alert("Es gibt aktuell keine Route zum Drucken.");
        return;
    }

    // Nur aktive Stopps mit g√ºltigen Koordinaten ber√ºcksichtigen
    const activeItems = stops
        .map((s, idx) => ({ s, idx }))
        .filter(item => item.s && item.s.lat != null && item.s.lon != null && item.s.active !== false);

    if (!activeItems.length) {
        alert("Es gibt keine aktiven, geokodierten Stopps zum Drucken.");
        return;
    }

    const coords = activeItems.map(item => [Number(item.s.lat), Number(item.s.lon)]);

    const summaryEl = document.getElementById("summaryInfo");
    const summaryText = summaryEl ? (summaryEl.textContent || "").trim() : "";

    // Tabelle f√ºr den Druck vorbereiten
    const printStops = activeItems.map((item, index) => {
        const s = item.s;
        let legText = "‚Äì";
        if (index === 0) {
            legText = "Start";
        } else if (s.fromPrevDistanceText || s.fromPrevDurationText) {
            const dist = s.fromPrevDistanceText || "";
            const dur = s.fromPrevDurationText || "";
            if (dist && dur) {
                legText = dist + " ¬∑ " + dur;
            } else {
                legText = dist || dur || "‚Äì";
            }
        }
        const address = (s.display || s.cleaned || "").trim();
        return {
            idx: index + 1,
            leg: legText || "‚Äì",
            address: address
        };
    });

    const payload = { coords, stops: printStops };

    function esc(str) {
        return String(str)
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;");
    }

    let html = "";
    html += "<!DOCTYPE html>";
    html += "<html><head><meta charset='utf-8'>";
    html += "<title>Route ‚Äì Druckansicht</title>";
    html += "<style>";
    html += "html,body{margin:0;padding:0;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Arial,sans-serif;font-size:11pt;color:#000;background:#fff;}";
    html += ".print-container{width:180mm;max-width:100%;margin:10mm auto 8mm auto;}";
    html += "h1{font-size:16pt;margin:0 0 2mm 0;}";
    html += "h2{font-size:11pt;margin:0 0 4mm 0;font-weight:normal;}";
    html += "#printCanvasWrapper{width:144mm;max-width:100%;height:72mm;border:0.4mm solid #000;box-sizing:border-box;margin-bottom:4mm;display:flex;align-items:center;justify-content:center;}";
    html += "#printCanvas{width:100%;height:100%;}";
    html += "table{width:100%;border-collapse:collapse;font-size:10pt;}";
    html += "th,td{padding:1.3mm 1.8mm;text-align:left;vertical-align:top;}tbody td{padding:0.35mm 1.8mm;}";
    html += "thead th{border-bottom:0.3mm solid #000;}";
    html += "tbody td{border-bottom:none;}";
    html += "th:nth-child(1),td:nth-child(1){width:8mm;text-align:center;}";
    html += "th:nth-child(2),td:nth-child(2){width:40mm;}";
    html += ".cell-address{word-break:break-word;}";
    html += "@page{size:A4;margin:10mm;}";
    html += "</style>";
    html += "</head><body>";
    html += "<div class='print-container'>";
    html += "<h1>Route</h1>";
    html += "<h2>" + (summaryText ? esc(summaryText) : "&#160;") + "</h2>";
    html += "<div id='printCanvasWrapper'><canvas id='printCanvas' width='1200' height='600'></canvas></div>";
    html += "<table><thead><tr><th>#</th><th>Fahrt von vorher</th><th>Adresse</th></tr></thead><tbody>";

    for (let i = 0; i < printStops.length; i++) {
        const row = printStops[i];
        html += "<tr>";
        html += "<td>" + esc(row.idx) + "</td>";
        html += "<td>" + esc(row.leg) + "</td>";
        html += "<td class='cell-address'>" + esc(row.address) + "</td>";
        html += "</tr>";
    }

    html += "</tbody></table>";
    html += "</div>";
    html += "<script>";
    html += "(function(){";
    html += "var data = window.PRINT_DATA || {};";
    html += "var coords = Array.isArray(data.coords) ? data.coords : [];";
    html += "var stops = Array.isArray(data.stops) ? data.stops : [];";
    html += "var canvas = document.getElementById('printCanvas');";
    html += "if (!canvas || !canvas.getContext) { window.print(); return; }";
    html += "var ctx = canvas.getContext('2d'); ctx.imageSmoothingEnabled = false;";
    html += "var w = canvas.width;";
    html += "var h = canvas.height;";
    html += "ctx.fillStyle = '#ffffff';";
    html += "ctx.fillRect(0,0,w,h);";
    html += "if (!coords.length) {";
    html += "  ctx.fillStyle = '#000000';";
    html += "  ctx.font = '14px sans-serif';";
    html += "  ctx.textAlign = 'center';";
    html += "  ctx.textBaseline = 'middle';";
    html += "  ctx.fillText('Keine Koordinaten vorhanden', w/2, h/2);";
    html += "  window.print();";
    html += "  return;";
    html += "}";
    html += "var latlngs = [];";
    html += "for (var i = 0; i < coords.length; i++) {";
    html += "  var lat = Number(coords[i][0]);";
    html += "  var lon = Number(coords[i][1]);";
    html += "  if (!isFinite(lat) || !isFinite(lon)) continue;";
    html += "  latlngs.push({ lat: lat, lon: lon });";
    html += "}";
    html += "if (!latlngs.length) {";
    html += "  ctx.fillStyle = '#000000';";
    html += "  ctx.font = '14px sans-serif';";
    html += "  ctx.textAlign = 'center';";
    html += "  ctx.textBaseline = 'middle';";
    html += "  ctx.fillText('Keine Koordinaten vorhanden', w/2, h/2);";
    html += "  window.print();";
    html += "  return;";
    html += "}";
    html += "var minZoom = 4, maxZoom = 17;";
    html += "function latLonToPixel(lat, lon, z) {";
    html += "  var sinLat = Math.sin(lat * Math.PI / 180);";
    html += "  var x = (lon + 180) / 360 * 256 * Math.pow(2, z);";
    html += "  var y = (0.5 - Math.log((1 + sinLat) / (1 - sinLat)) / (4 * Math.PI)) * 256 * Math.pow(2, z);";
    html += "  return { x: x, y: y };";
    html += "}";
    html += "function chooseView() {";
    html += "  var best = null;";
    html += "  for (var z = maxZoom; z >= minZoom; z--) {";
    html += "    var minX, maxX, minY, maxY;";
    html += "    for (var i = 0; i < latlngs.length; i++) {";
    html += "      var p = latLonToPixel(latlngs[i].lat, latlngs[i].lon, z);";
    html += "      if (i === 0) { minX = maxX = p.x; minY = maxY = p.y; }";
    html += "      else {";
    html += "        if (p.x < minX) minX = p.x;";
    html += "        if (p.x > maxX) maxX = p.x;";
    html += "        if (p.y < minY) minY = p.y;";
    html += "        if (p.y > maxY) maxY = p.y;";
    html += "      }";
    html += "    }";
    html += "    var tilesX = (maxX - minX) / 256;";
    html += "    var tilesY = (maxY - minY) / 256;";
    html += "    if (!best) best = { z: z, minX: minX, maxX: maxX, minY: minY, maxY: maxY };";
    html += "    if (tilesX <= 2.7 && tilesY <= 1.8) {";
    html += "      best = { z: z, minX: minX, maxX: maxX, minY: minY, maxY: maxY };";
    html += "      break;";
    html += "    }";
    html += "  }";
    html += "  var dX = best.maxX - best.minX;";
    html += "  var dY = best.maxY - best.minY;";
    html += "  best.minX -= dX * 0.05;";
    html += "  best.maxX += dX * 0.05;";
    html += "  best.minY -= dY * 0.05;";
    html += "  best.maxY += dY * 0.05;";
    html += "  return best;";
    html += "}";
    html += "var view = chooseView();";
    html += "var margin = 24;";
    html += "var innerW = w - 2 * margin;";
    html += "var innerH = h - 2 * margin;";
    html += "var worldW = view.maxX - view.minX;";
    html += "var worldH = view.maxY - view.minY;";
    html += "if (worldW <= 0) worldW = 1;";
    html += "if (worldH <= 0) worldH = 1;";
    html += "var scale = Math.min(innerW / worldW, innerH / worldH);";
    html += "var offsetX = margin + (innerW - worldW * scale) / 2;";
    html += "var offsetY = margin + (innerH - worldH * scale) / 2;";
    html += "function project(lat, lon) {";
    html += "  var p = latLonToPixel(lat, lon, view.z);";
    html += "  var x = offsetX + (p.x - view.minX) * scale;";
    html += "  var y = offsetY + (p.y - view.minY) * scale;";
    html += "  return { x: x, y: y };";
    html += "}";
    html += "var tileMinX = Math.floor(view.minX / 256);";
    html += "var tileMaxX = Math.floor(view.maxX / 256);";
    html += "var tileMinY = Math.floor(view.minY / 256);";
    html += "var tileMaxY = Math.floor(view.maxY / 256);";
    html += "var tiles = [];";
    html += "for (var ty = tileMinY; ty <= tileMaxY; ty++) {";
    html += "  for (var tx = tileMinX; tx <= tileMaxX; tx++) {";
    html += "    var subIndex = Math.abs(tx + ty) % 3;";
    html += "    var sub = subIndex === 0 ? 'a' : (subIndex === 1 ? 'b' : 'c');";
    html += "    var url = 'https://' + sub + '.tile.openstreetmap.org/' + view.z + '/' + tx + '/' + ty + '.png';";
    html += "    tiles.push({ x: tx, y: ty, url: url, img: null });";
    html += "  }";
    html += "}";
    html += "var remaining = tiles.length;";
    html += "var timeoutHandle = null;";
    html += "function drawEverything() {";
    html += "  if (timeoutHandle) clearTimeout(timeoutHandle);";
    html += "  ctx.fillStyle = '#ffffff';";
    html += "  ctx.fillRect(0,0,w,h);";
    html += "  ctx.filter = 'grayscale(100%) contrast(125%)';";
    html += "  for (var i = 0; i < tiles.length; i++) {";
    html += "    var t = tiles[i];";
    html += "    if (!t.img || !t.img.complete) continue;";
    html += "    var tilePxX = t.x * 256;";
    html += "    var tilePxY = t.y * 256;";
    html += "    var x = offsetX + (tilePxX - view.minX) * scale;";
    html += "    var y = offsetY + (tilePxY - view.minY) * scale;";
    html += "    var dw = 256 * scale;";
    html += "    var dh = 256 * scale;";
    html += "    try { ctx.drawImage(t.img, x, y, dw, dh); } catch(e) {}";
    html += "  }";
    html += "  ctx.strokeStyle = 'rgba(0,0,0,0.1)';";
    html += "  ctx.lineWidth = 1;";
    html += "  var gridLines = 4;";
    html += "  for (var g = 1; g < gridLines; g++) {";
    html += "    var gy = margin + innerH * g / gridLines;";
    html += "    ctx.beginPath();";
    html += "    ctx.moveTo(margin, gy);";
    html += "    ctx.lineTo(w - margin, gy);";
    html += "    ctx.stroke();";
    html += "  }";
    html += "  ctx.strokeStyle = '#000000';";
    html += "  ctx.lineWidth = 3;";
    html += "  ctx.lineJoin = 'round';";
    html += "  ctx.lineCap = 'round';";
    html += "  var firstProj = project(latlngs[0].lat, latlngs[0].lon);";
    html += "  ctx.beginPath();";
    html += "  ctx.moveTo(firstProj.x, firstProj.y);";
    html += "  for (var j = 1; j < latlngs.length; j++) {";
    html += "    var p = project(latlngs[j].lat, latlngs[j].lon);";
    html += "    ctx.lineTo(p.x, p.y);";
    html += "  }";
    html += "  ctx.stroke();";
    html += "  ctx.font = 'bold 16px sans-serif';";
    html += "  ctx.textAlign = 'center';";
    html += "  ctx.textBaseline = 'middle';";
    html += "  for (var k = 0; k < latlngs.length; k++) {";
    html += "    var pt = project(latlngs[k].lat, latlngs[k].lon);";
    html += "    var label = '';";
    html += "    if (k === 0) label = 'S';";
    html += "    else if (k === latlngs.length - 1) label = 'Z';";
    html += "    else label = String(stops[k] && stops[k].idx ? stops[k].idx : (k + 1));";
    html += "    var rOuter = 30;";
    html += "    var rInner = 26;";
    html += "    ctx.fillStyle = '#ffffff';";
    html += "    ctx.beginPath();";
    html += "    ctx.arc(pt.x, pt.y, rOuter, 0, Math.PI * 2, false);";
    html += "    ctx.fill();";
    html += "    ctx.strokeStyle = '#000000';";
    html += "    ctx.lineWidth = 2;";
    html += "    ctx.stroke();";
    html += "    ctx.beginPath();";
    html += "    ctx.arc(pt.x, pt.y, rInner, 0, Math.PI * 2, false);";
    html += "    ctx.stroke();";
    html += "    ctx.fillStyle = '#000000';";
    html += "    ctx.fillText(label, pt.x, pt.y);";
    html += "  }";
    html += "  setTimeout(function(){ window.focus(); window.print(); setTimeout(function(){ window.close(); }, 300); }, 80);";
    html += "}";
    html += "if (!tiles.length) {";
    html += "  drawEverything();";
    html += "  return;";
    html += "}";
    html += "remaining = tiles.length;";
    html += "for (var i = 0; i < tiles.length; i++) {";
    html += "  (function(tile){";
    html += "    var img = new Image();";
    html += "    tile.img = img;";
    html += "    img.onload = img.onerror = function(){";
    html += "      remaining--;";
    html += "      if (remaining <= 0) {";
    html += "        drawEverything();";
    html += "      }";
    html += "    };";
    html += "    img.src = tile.url;";
    html += "  })(tiles[i]);";
    html += "}";
    html += "timeoutHandle = setTimeout(function(){ drawEverything(); }, 4000);";
    html += "})();";
    html += "</";
    html += "script>";
    html += "</body></html>";

    const win = window.open("", "_blank");
    if (!win) {
        alert("Popup-Fenster blockiert. Bitte Popups f√ºr diese Seite erlauben.");
        return;
    }
    win.PRINT_DATA = payload;
    win.document.open();
    win.document.write(html);
    win.document.close();
    win.focus();
}





    function loadRoutes() {
        try {
            const stored = localStorage.getItem(ROUTES_KEY);
            if (stored) {
                return JSON.parse(stored);
            }
        } catch (e) {
            console.warn("Konnte Routen nicht laden:", e);
        }
        return [];
    }

    function saveRoutes(routes) {
        try {
            localStorage.setItem(ROUTES_KEY, JSON.stringify(routes));
        } catch (e) {
            console.warn("Konnte Routen nicht speichern:", e);
        }
    }

    function persistCurrentRoute(nameOrNull, autoLabel) {
        if (!stops.length) return false;
        const now = new Date();
        const createdAt = now.toISOString();
        const summary = document.getElementById("summaryInfo").textContent || "";
        let name = nameOrNull && nameOrNull.trim ? nameOrNull.trim() : nameOrNull;
        if (!name && autoLabel) {
            name = "[Auto] " + autoLabel;
        }
        const routeData = {
            id: "r_" + now.getTime(),
            name: name || null,
            createdAt: createdAt,
            stopCount: stops.length,
            summary: summary,
            stops: stops.map(s => s.cleaned)
        };
        let routes = loadRoutes();
        routes.unshift(routeData);
        if (routes.length > 50) routes = routes.slice(0, 50);
        saveRoutes(routes);
        return true;
    }

    
    function loadFavorites() {
        try {
            const stored = localStorage.getItem(FAVORITES_KEY);
            if (stored) {
                return JSON.parse(stored);
            }
        } catch (e) {
            console.warn("Konnte Favoriten nicht laden:", e);
        }
        return [];
    }

    function saveFavorites(favorites) {
        try {
            localStorage.setItem(FAVORITES_KEY, JSON.stringify(favorites));
        } catch (e) {
            console.warn("Konnte Favoriten nicht speichern:", e);
        }
    }

    function buildRouteNameSuggestion(routeData) {
        const stopsArr = routeData && Array.isArray(routeData.stops) ? routeData.stops : [];
        let base = "";
        if (stopsArr.length >= 2) {
            base = (stopsArr[0] || "").trim() + " \u2192 " + (stopsArr[stopsArr.length - 1] || "").trim();
        } else if (stopsArr.length === 1) {
            base = (stopsArr[0] || "").trim();
        }
        if (!base) {
            const count = routeData && routeData.stopCount ? routeData.stopCount : stopsArr.length;
            base = "Route mit " + count + " Stopps";
        }
        return base;
    }

    function downloadJson(filename, data) {
        try {
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        } catch (e) {
            console.warn("Konnte Datei nicht zum Download bereitstellen:", e);
        }
    }

    function downloadRoutesHistory() {
        const routes = loadRoutes();
        if (!routes.length) {
            alert("Im Routenverlauf sind keine Eintr√§ge vorhanden.");
            return;
        }
        downloadJson("routenverlauf.json", routes);
    }

    function downloadFavorites() {
        const favorites = loadFavorites();
        if (!favorites.length) {
            alert("Es sind noch keine Favoriten gespeichert.");
            return;
        }
        downloadJson("routen_favoriten.json", favorites);
    }

    function downloadRoutesAndFavoritesCombined() {
        const routes = loadRoutes();
        const favorites = loadFavorites();
        if ((!routes || !routes.length) && (!favorites || !favorites.length)) {
            alert("Es sind noch keine Daten zum Export vorhanden (weder Routenverlauf noch Favoriten).");
            return;
        }
        const payload = {
            version: 1,
            exportedAt: new Date().toISOString(),
            routes: Array.isArray(routes) ? routes : [],
            favorites: Array.isArray(favorites) ? favorites : []
        };
        downloadJson("routen_und_favoriten.json", payload);
    }

    function openJsonFileForImport(onDataLoaded) {
        try {
            const input = document.createElement("input");
            input.type = "file";
            input.accept = "application/json,.json";
            input.addEventListener("change", (event) => {
                const file = event.target && event.target.files ? event.target.files[0] : null;
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const text = String(e.target.result || "");
                        const data = JSON.parse(text);
                        onDataLoaded(data);
                    } catch (err) {
                        console.error("Fehler beim Lesen der Import-Datei:", err);
                        alert("Die Datei konnte nicht gelesen werden. Ist es eine g√ºltige JSON-Datei?");
                    }
                };
                reader.readAsText(file, "utf-8");
            });
            input.click();
        } catch (err) {
            console.error("Fehler beim √ñffnen des Datei-Dialogs:", err);
            alert("Die Import-Funktion wird von diesem Browser nicht unterst√ºtzt.");
        }
    }

    function mergeItemsById(preferredFirst, existing) {
        const merged = [];
        const seen = new Set();
        const addList = (list) => {
            if (!Array.isArray(list)) return;
            for (const item of list) {
                if (!item || typeof item !== "object") continue;
                const id = item.id || null;
                const key = id != null ? String(id) : null;
                const mapKey = key || JSON.stringify(item);
                if (seen.has(mapKey)) continue;
                seen.add(mapKey);
                merged.push(item);
            }
        };
        addList(preferredFirst);
        addList(existing);
        return merged;
    }

    function importRoutesAndFavoritesFromJson(focus) {
        openJsonFileForImport((data) => {
            let importedRoutes = [];
            let importedFavorites = [];

            if (Array.isArray(data)) {
                if (data.length && typeof data[0] === "object" && data[0] !== null) {
                    const first = data[0];
                    const id = first.id ? String(first.id) : "";
                    if (id.startsWith("f_")) {
                        importedFavorites = data;
                    } else {
                        importedRoutes = data;
                    }
                }
            } else if (data && typeof data === "object") {
                if (Array.isArray(data.routes)) {
                    importedRoutes = data.routes;
                }
                if (Array.isArray(data.favorites)) {
                    importedFavorites = data.favorites;
                }
            }

            if ((!importedRoutes || !importedRoutes.length) && (!importedFavorites || !importedFavorites.length)) {
                alert("In der gew√§hlten Datei wurden keine geeigneten Routen- oder Favoritendaten gefunden.");
                return;
            }

            if (importedRoutes && importedRoutes.length) {
                const existingRoutes = loadRoutes();
                const mergedRoutes = mergeItemsById(importedRoutes, existingRoutes);
                // Routenverlauf bleibt auf 50 Eintr√§ge begrenzt
                saveRoutes(mergedRoutes.slice(0, 50));
            }

            if (importedFavorites && importedFavorites.length) {
                const existingFavorites = loadFavorites();
                const mergedFavorites = mergeItemsById(importedFavorites, existingFavorites);
                saveFavorites(mergedFavorites);
            }

            if (importedRoutes.length && importedFavorites.length) {
                alert("Routenverlauf und Favoriten wurden importiert.");
            } else if (importedRoutes.length) {
                alert("Routenverlauf wurde importiert.");
            } else {
                alert("Favoriten wurden importiert.");
            }

            if (focus === "favorites") {
                openFavoritesModal();
            } else {
                openRoutesModal();
            }
        });
    }

    

// --- Dateisystem-gest√ºtzter Import/Export NUR f√ºr Routenverlauf ---
async function openRoutesFsDb() {
    return new Promise((resolve, reject) => {
        if (!window.indexedDB) {
            reject(new Error("IndexedDB wird von diesem Browser nicht unterst√ºtzt."));
            return;
        }
        const request = indexedDB.open(ROUTES_FS_DB_NAME, 1);
        request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(ROUTES_FS_STORE)) {
                db.createObjectStore(ROUTES_FS_STORE);
            }
        };
        request.onsuccess = (event) => {
            resolve(event.target.result);
        };
        request.onerror = (event) => {
            reject(event.target.error || new Error("Fehler beim √ñffnen der IndexedDB."));
        };
    });
}

async function saveRoutesDirectoryHandle(handle) {
    try {
        const db = await openRoutesFsDb();
        await new Promise((resolve, reject) => {
            const tx = db.transaction(ROUTES_FS_STORE, "readwrite");
            const store = tx.objectStore(ROUTES_FS_STORE);
            const req = store.put(handle, ROUTES_FS_KEY);
            tx.oncomplete = () => resolve();
            tx.onerror = () => reject(tx.error);
            req.onerror = () => reject(req.error);
        });
    } catch (err) {
        console.error("Konnte Routen-Ordner-Handle nicht speichern:", err);
    }
}

async function loadRoutesDirectoryHandleFromDb() {
    if (routesDirectoryHandleLoaded) return routesDirectoryHandle;
    routesDirectoryHandleLoaded = true;
    try {
        const db = await openRoutesFsDb();
        const handle = await new Promise((resolve, reject) => {
            const tx = db.transaction(ROUTES_FS_STORE, "readonly");
            const store = tx.objectStore(ROUTES_FS_STORE);
            const req = store.get(ROUTES_FS_KEY);
            tx.oncomplete = () => resolve(req.result || null);
            tx.onerror = () => reject(tx.error);
            req.onerror = () => reject(req.error);
        });
        routesDirectoryHandle = handle || null;
    } catch (err) {
        console.warn("Konnte gespeicherten Routen-Ordner nicht laden:", err);
        routesDirectoryHandle = null;
    }
    return routesDirectoryHandle;
}

async function clearSavedRoutesDirectoryHandle() {
    routesDirectoryHandle = null;
    routesDirectoryHandleLoaded = false;
    try {
        const db = await openRoutesFsDb();
        await new Promise((resolve, reject) => {
            const tx = db.transaction(ROUTES_FS_STORE, "readwrite");
            const store = tx.objectStore(ROUTES_FS_STORE);
            const req = store.delete(ROUTES_FS_KEY);
            tx.oncomplete = () => resolve();
            tx.onerror = () => reject(tx.error);
            req.onerror = () => reject(req.error);
        });
    } catch (err) {
        console.error("Konnte gespeicherten Routen-Ordner nicht l√∂schen:", err);
    }
}

function importRoutesFromJsonData(data) {
    let importedRoutes = [];

    if (Array.isArray(data)) {
        importedRoutes = data;
    } else if (data && typeof data === "object") {
        if (Array.isArray(data.routes)) {
            importedRoutes = data.routes;
        }
    }

    if (!importedRoutes || !importedRoutes.length) {
        alert("In der gew√§hlten Datei wurden keine geeigneten Routen-Daten gefunden.");
        return;
    }

    const existingRoutes = loadRoutes();
    const mergedRoutes = mergeItemsById(importedRoutes, existingRoutes);
    // Routenverlauf bleibt auf 50 Eintr√§ge begrenzt
    saveRoutes(mergedRoutes.slice(0, 50));
    alert("Routenverlauf wurde importiert.");
}

function fallbackExportRoutesToJson() {
    const routes = loadRoutes();
    if (!routes || !routes.length) {
        alert("Im Routenverlauf sind keine Eintr√§ge vorhanden.");
        return;
    }
    downloadJson("routenverlauf.json", routes);
}

function fallbackImportRoutesFromJson() {
    openJsonFileForImport(importRoutesFromJsonData);
}

async function exportRoutesWithFsApi() {
    try {
        if (!window.isSecureContext || typeof window.showDirectoryPicker !== "function") {
            fallbackExportRoutesToJson();
            return;
        }

        const routes = loadRoutes();
        if (!routes || !routes.length) {
            alert("Im Routenverlauf sind keine Eintr√§ge vorhanden.");
            return;
        }

        if (!routesDirectoryHandleLoaded) {
            await loadRoutesDirectoryHandleFromDb();
        }

        if (!routesDirectoryHandle) {
            try {
                routesDirectoryHandle = await window.showDirectoryPicker();
                await saveRoutesDirectoryHandle(routesDirectoryHandle);
            } catch (err) {
                if (err && err.name === "AbortError") {
                    // Benutzer hat abgebrochen
                    return;
                }
                console.error("Ordnerwahl f√ºr Routen-Export abgebrochen/fehlgeschlagen:", err);
                fallbackExportRoutesToJson();
                return;
            }
        }

        let fileHandle;
        try {
            fileHandle = await routesDirectoryHandle.getFileHandle("routenverlauf.json", { create: true });
        } catch (err) {
            console.error("Konnte Datei-Handle f√ºr Routen nicht erzeugen:", err);
            await clearSavedRoutesDirectoryHandle();
            fallbackExportRoutesToJson();
            return;
        }

        try {
            const writable = await fileHandle.createWritable();
            await writable.write(JSON.stringify(routes, null, 2));
            await writable.close();
            setPanelStatus("Routenverlauf im gew√§hlten Ordner gespeichert.");
        } catch (err) {
            console.error("Fehler beim Schreiben der Routen-Datei:", err);
            await clearSavedRoutesDirectoryHandle();
            fallbackExportRoutesToJson();
        }
    } catch (err) {
        console.error("Unerwarteter Fehler beim Routen-Export:", err);
        fallbackExportRoutesToJson();
    }
}

async function importRoutesWithFsApi() {
    try {
        if (!window.isSecureContext || typeof window.showDirectoryPicker !== "function") {
            fallbackImportRoutesFromJson();
            return;
        }

        if (!routesDirectoryHandleLoaded) {
            await loadRoutesDirectoryHandleFromDb();
        }

        if (!routesDirectoryHandle) {
            try {
                routesDirectoryHandle = await window.showDirectoryPicker();
                await saveRoutesDirectoryHandle(routesDirectoryHandle);
            } catch (err) {
                if (err && err.name === "AbortError") {
                    // Benutzer hat abgebrochen
                    return;
                }
                console.error("Ordnerwahl f√ºr Routen-Import abgebrochen/fehlgeschlagen:", err);
                fallbackImportRoutesFromJson();
                return;
            }
        }

        let fileHandle;
        try {
            fileHandle = await routesDirectoryHandle.getFileHandle("routenverlauf.json", { create: false });
        } catch (err) {
            console.error("Konnte Routen-Datei im gew√§hlten Ordner nicht finden:", err);
            alert("Die Datei 'routenverlauf.json' wurde im gew√§hlten Ordner nicht gefunden. Bitte w√§hle die Datei manuell aus.");
            fallbackImportRoutesFromJson();
            return;
        }

        try {
            const file = await fileHandle.getFile();
            const text = await file.text();
            const data = JSON.parse(text);
            importRoutesFromJsonData(data);
            setPanelStatus("Routenverlauf aus Datei importiert.");
        } catch (err) {
            console.error("Fehler beim Lesen der Routen-Datei:", err);
            alert("Die Routen-Datei konnte nicht gelesen werden. Bitte w√§hle die Datei ggf. manuell aus.");
            await clearSavedRoutesDirectoryHandle();
            fallbackImportRoutesFromJson();
        }
    } catch (err) {
        console.error("Unerwarteter Fehler beim Routen-Import:", err);
        fallbackImportRoutesFromJson();
    }
}

let pendingFavoriteContext = null;

    function openFavoriteSaveModalForRoute(routeData, prefillName) {
        if (!routeData || !Array.isArray(routeData.stops) || !routeData.stops.length) {
            alert("F√ºr diese Route liegen keine Stopps vor.");
            return;
        }
        const stopsArr = routeData.stops;
        const start = stopsArr[0] || "";
        const end = stopsArr.length > 1 ? (stopsArr[stopsArr.length - 1] || "") : "";
        const dt = routeData.createdAt ? formatDateTimeShort(routeData.createdAt) : formatDateTimeShort(new Date().toISOString());

        const summaryEl = document.getElementById("favoriteSaveSummary");
        if (summaryEl) {
            summaryEl.textContent = "Start: " + start + " | Ziel: " + (end || "‚Äì") + " | " + dt + " | " + (routeData.stopCount || stopsArr.length) + " Adressen";
        }

        const input = document.getElementById("favoriteNameInput");
        if (input) {
            const suggested = prefillName || routeData.name || buildRouteNameSuggestion(routeData);
            input.value = suggested;
            input.focus();
            input.select();
        }

        pendingFavoriteContext = { routeData: routeData };
        const backdrop = document.getElementById("favoriteSaveModalBackdrop");
        if (backdrop) backdrop.style.display = "flex";
    }

    function closeFavoriteSaveModal() {
        pendingFavoriteContext = null;
        const backdrop = document.getElementById("favoriteSaveModalBackdrop");
        if (backdrop) backdrop.style.display = "none";
    }

    function confirmFavoriteSaveFromModal() {
        if (!pendingFavoriteContext || !pendingFavoriteContext.routeData) {
            closeFavoriteSaveModal();
            return;
        }
        const routeData = pendingFavoriteContext.routeData;
        const input = document.getElementById("favoriteNameInput");
        let name = input ? input.value.trim() : "";
        if (!name) {
            name = buildRouteNameSuggestion(routeData);
        }
        const favorites = loadFavorites();
        const nowIso = new Date().toISOString();
        const stopsArr = Array.isArray(routeData.stops) ? routeData.stops.slice() : [];
        const fav = {
            id: routeData.id ? "f_" + routeData.id : "f_" + Date.now(),
            name: name,
            createdAt: routeData.createdAt || nowIso,
            stopCount: routeData.stopCount || stopsArr.length,
            summary: routeData.summary || "",
            stops: stopsArr
        };
        favorites.unshift(fav);
        saveFavorites(favorites);
        closeFavoriteSaveModal();
        alert("Route wurde als Favorit gespeichert.");
    }

    function openFavoriteSaveModalFromCurrent() {
        if (!stops.length) {
            setPanelStatus("Es gibt aktuell nichts zu speichern.");
            alert("Es ist keine Route geladen, die als Favorit gespeichert werden k√∂nnte.");
            return;
        }
        const now = new Date();
        const summary = document.getElementById("summaryInfo").textContent || "";
        const routeData = {
            id: "r_current_" + now.getTime(),
            name: null,
            createdAt: now.toISOString(),
            stopCount: stops.length,
            summary: summary,
            stops: stops.map(s => s.cleaned)
        };
        openFavoriteSaveModalForRoute(routeData, null);
    }

    function openFavoriteSaveModalFromHistory(index) {
        const routes = loadRoutes();
        if (index < 0 || index >= routes.length) return;
        const route = routes[index];
        const suggested = route.name || buildRouteNameSuggestion(route);
        openFavoriteSaveModalForRoute(route, suggested);
    }

    function openFavoritesModal() {
        const backdrop = document.getElementById("favoritesModalBackdrop");
        const container = document.getElementById("favoritesListContainer");
        const favorites = loadFavorites();
        if (!favorites.length) {
            container.innerHTML = "<div class='routes-empty'>Es wurden noch keine Favoriten gespeichert.</div>";
        } else {
            let html = "<table class='routes-list'><thead><tr>" +
                "<th>Start</th><th>Ziel</th><th>Name</th><th>Datum</th><th>Adressen</th><th>Aktion</th>" +
                "</tr></thead><tbody>";
            favorites.forEach((f, idx) => {
                const stopsArr = Array.isArray(f.stops) ? f.stops : [];
                const start = stopsArr.length ? (stopsArr[0] || "") : "";
                const end = stopsArr.length > 1 ? (stopsArr[stopsArr.length - 1] || "") : "";
                html += "<tr>";
                html += "<td>" + (start ? start.replace(/</g,"&lt;").replace(/>/g,"&gt;") : "\u2013") + "</td>";
                html += "<td>" + (end ? end.replace(/</g,"&lt;").replace(/>/g,"&gt;") : "\u2013") + "</td>";
                html += "<td>" + (f.name ? f.name.replace(/</g,"&lt;").replace(/>/g,"&gt;") : "") + "</td>";
                html += "<td>" + formatDateTimeShort(f.createdAt) + "</td>";
                const stopCount = (f.stopCount || stopsArr.length || 0);
                html += "<td>" + stopCount + " ‚öë</td>";
                html += "<td>" +
                    "<button data-index='" + idx + "' class='btn-small fav-open-btn'>√ñffnen</button> " +
                    "<button data-index='" + idx + "' class='btn-small fav-delete-btn'>Entfernen</button>" +
                    "</td>";
                html += "</tr>";
            });
            html += "</tbody></table>";
            container.innerHTML = html;

            const openButtons = container.querySelectorAll(".fav-open-btn");
            openButtons.forEach(btn => {
                btn.addEventListener("click", function() {
                    const idx = Number(this.getAttribute("data-index"));
                    loadFavoriteByIndex(idx);
                });
            });
            const deleteButtons = container.querySelectorAll(".fav-delete-btn");
            deleteButtons.forEach(btn => {
                btn.addEventListener("click", function() {
                    const idx = Number(this.getAttribute("data-index"));
                    deleteFavoriteByIndex(idx);
                });
            });
        }
        if (backdrop) backdrop.style.display = "flex";
    }

    function closeFavoritesModal() {
        const backdrop = document.getElementById("favoritesModalBackdrop");
        if (backdrop) backdrop.style.display = "none";
    }

    function loadFavoriteByIndex(index) {
        const favorites = loadFavorites();
        if (index < 0 || index >= favorites.length) return;
        const fav = favorites[index];
        const rawText = Array.isArray(fav.stops) ? fav.stops.join("\\n") : "";
        closeFavoritesModal();
        document.getElementById("modalAddressInput").value = rawText;
        openImportModal();
        alert("Der Favorit wurde in den Einf√ºhren-Dialog geladen.\\nDu kannst ihn noch bearbeiten und dann erneut auf 'Einf√ºhren' klicken.");
    }

    function deleteFavoriteByIndex(index) {
        const favorites = loadFavorites();
        if (index < 0 || index >= favorites.length) return;
        if (!confirm("Diesen Favoriten l√∂schen?")) return;
        favorites.splice(index, 1);
        saveFavorites(favorites);
        openFavoritesModal();
    }


    function handleSaveRoute() {
        if (!stops.length) {
            setPanelStatus("Es gibt aktuell nichts zu speichern.");
            alert("Es ist keine Route geladen, die als Favorit gespeichert werden k√∂nnte.");
            return;
        }
        openFavoriteSaveModalFromCurrent();
    }

    function handleDeleteRoute() {
        if (!stops.length) {
            alert("Es gibt aktuell keine Route zum L√∂schen.");
            return;
        }
        if (!confirm("Aktuelle Route l√∂schen? Die Route wird vorher automatisch in 'Routen' abgelegt.")) {
            return;
        }
        persistCurrentRoute(null, "L√∂schen");
        resetAll();
    }


    function handleRouteCalculateClick() {
        if (!stops.length) {
            alert("Es sind keine Stopps geladen.");
            return;
        }
        const locStops = stops.filter(s => s.lat !== null && s.lon !== null && s.active !== false);
        if (locStops.length < 2) {
            alert("F√ºr eine Route werden mindestens zwei g√ºltige, geokodierte Stopps ben√∂tigt.");
            return;
        }
        buildRouteFromLocations();
    }

    function formatDateTimeShort(iso) {
        const d = new Date(iso);
        if (isNaN(d.getTime())) return iso;
        const day = String(d.getDate()).padStart(2, "0");
        const month = String(d.getMonth() + 1).padStart(2, "0");
        const year = d.getFullYear();
        const hour = String(d.getHours()).padStart(2, "0");
        const min = String(d.getMinutes()).padStart(2, "0");
        return day + "." + month + "." + year + " " + hour + ":" + min + " Uhr";
    }

    function openRoutesModal() {
        const backdrop = document.getElementById("routesModalBackdrop");
        const container = document.getElementById("routesListContainer");
        const routes = loadRoutes();
        if (!routes.length) {
            container.innerHTML = "<div class='routes-empty'>Es wurden noch keine Routen im Verlauf gespeichert.</div>";
        } else {
            let html = "<table class='routes-list'><thead><tr>" +
                "<th>Start</th><th>Ziel</th><th>Datum</th><th>Adressen</th><th>Aktion</th>" +
                "</tr></thead><tbody>";
            routes.forEach((r, idx) => {
                const stopsArr = Array.isArray(r.stops) ? r.stops : [];
                const start = stopsArr.length ? (stopsArr[0] || "") : "";
                const end = stopsArr.length > 1 ? (stopsArr[stopsArr.length - 1] || "") : "";
                html += "<tr>";
                html += "<td>" + (start ? start.replace(/</g,"&lt;").replace(/>/g,"&gt;") : "\u2013") + "</td>";
                html += "<td>" + (end ? end.replace(/</g,"&lt;").replace(/>/g,"&gt;") : "\u2013") + "</td>";
                html += "<td>" + formatDateTimeShort(r.createdAt) + "</td>";
                const stopCount = (r.stopCount || stopsArr.length || 0);
                html += "<td>" + stopCount + " ‚öë</td>";
                html += "<td>" +
                    "<button data-index='" + idx + "' class='btn-small route-open-btn'>√ñffnen</button> " +
                    "<button data-index='" + idx + "' class='btn-small route-fav-btn'>Speichern</button> " +
                    "<button data-index='" + idx + "' class='btn-small route-delete-btn'>Entfernen</button>" +
                    "</td>";
                html += "</tr>";
            });
            html += "</tbody></table>";
            container.innerHTML = html;

            const openButtons = container.querySelectorAll(".route-open-btn");
            openButtons.forEach(btn => {
                btn.addEventListener("click", function() {
                    const idx = Number(this.getAttribute("data-index"));
                    loadRouteByIndex(idx);
                });
            });

            const favButtons = container.querySelectorAll(".route-fav-btn");
            favButtons.forEach(btn => {
                btn.addEventListener("click", function() {
                    const idx = Number(this.getAttribute("data-index"));
                    openFavoriteSaveModalFromHistory(idx);
                });
            });

            const deleteButtons = container.querySelectorAll(".route-delete-btn");
            deleteButtons.forEach(btn => {
                btn.addEventListener("click", function() {
                    const idx = Number(this.getAttribute("data-index"));
                    deleteRouteFromHistory(idx);
                });
            });
        }
        if (backdrop) backdrop.style.display = "flex";
    }

    function closeRoutesModal() {
        const backdrop = document.getElementById("routesModalBackdrop");
        if (backdrop) backdrop.style.display = "none";
    }

    function deleteRouteFromHistory(index) {
        const routes = loadRoutes();
        if (index < 0 || index >= routes.length) return;
        if (!confirm("Diese Route aus dem Verlauf entfernen?")) return;
        routes.splice(index, 1);
        saveRoutes(routes);
        openRoutesModal();
    }

    function loadRouteByIndex(index) {
        const routes = loadRoutes();
        if (index < 0 || index >= routes.length) return;
        const route = routes[index];
        const rawText = route.stops.join("\n");
        closeRoutesModal();
        document.getElementById("modalAddressInput").value = rawText;
        openImportModal();
        alert("Die gespeicherte Route wurde in den Einf√ºhren-Dialog geladen.\nDu kannst sie noch bearbeiten und dann erneut auf 'Einf√ºhren' klicken.");
    }

    function openOptionsModal() {
        const s = currentSettings;
        document.getElementById("optStartTime").value = s.startTime;
        document.getElementById("optRangeHandling").value = s.rangeHandling;
        document.getElementById("optAutoNormalize").value = s.autoNormalize;
        document.getElementById("optUnit").value = s.unit;
        document.getElementById("optionsModalBackdrop").style.display = "flex";
    }

    function closeOptionsModal() {
        document.getElementById("optionsModalBackdrop").style.display = "none";
    }

    function saveOptionsFromModal() {
        const s = {
            startTime: document.getElementById("optStartTime").value || "07:30",
            rangeHandling: document.getElementById("optRangeHandling").value,
            autoNormalize: document.getElementById("optAutoNormalize").value,
            unit: document.getElementById("optUnit").value
        };
        currentSettings = s;
        saveSettings(s);
        closeOptionsModal();
        // Hinweis-Dialog entfernt ‚Äì Einstellungen werden still gespeichert.

    }

    function resetOptionsToDefaults() {
        currentSettings = {
            startTime: "07:30",
            rangeHandling: "first",
            autoNormalize: "on",
            unit: "km"
        };
        saveSettings(currentSettings);
        openOptionsModal();
    }

    function toggleMapDim() {
        if (!map) return;
        mapDimmed = !mapDimmed;
        // Einziger Unterschied zwischen den Ansichten ist der CSS-Filter
        document.body.classList.toggle("dimmed", mapDimmed);
    }

    
function showStopMenu(index, latLng) {
        const menu = document.getElementById("stopMenu");
        const titleEl = document.getElementById("stopMenuTitle");
        const stop = stops[index];
        if (!menu || !stop || !map) return;
        stopMenuIndex = index;
        const titleAddress = stop.display || stop.cleaned;
        titleEl.textContent = (index + 1) + ". " + titleAddress;

        // Button-Text f√ºr Aktiv/Inaktiv dynamisch anpassen
        const toggleBtn = document.getElementById("stopMenuToggleActiveBtn");
        if (toggleBtn) {
            const labelSpan = toggleBtn.querySelector("span:nth-child(2)");
            if (labelSpan) {
                if (stop.active === false) {
                    labelSpan.textContent = "Aktivieren";
                } else {
                    labelSpan.textContent = "Inaktiv setzen";
                }
            }
        }

        const point = map.latLngToContainerPoint(latLng);

        // Grundposition setzen (√ºber dem Marker, zentriert)
        menu.style.display = "block";
        menu.style.left = point.x + "px";
        menu.style.top = point.y + "px";

        // Sicherstellen, dass das Men√º vollst√§ndig im sichtbaren Bereich bleibt
        try {
            const rect = menu.getBoundingClientRect();
            const padding = 8;
            let dx = 0;
            let dy = 0;

            // Begrenzung nicht nur an das Fenster, sondern an den sichtbaren Kartenbereich
            let boundsLeft = padding;
            let boundsTop = padding;
            let boundsRight = window.innerWidth - padding;
            let boundsBottom = window.innerHeight - padding;

            if (map && typeof map.getContainer === "function") {
                const containerRect = map.getContainer().getBoundingClientRect();
                boundsLeft = containerRect.left + padding;
                boundsTop = containerRect.top + padding;
                boundsRight = containerRect.right - padding;
                boundsBottom = containerRect.bottom - padding;
            }

            if (rect.left < boundsLeft) {
                dx = boundsLeft - rect.left;
            } else if (rect.right > boundsRight) {
                dx = boundsRight - rect.right;
            }

            if (rect.top < boundsTop) {
                dy = boundsTop - rect.top;
            } else if (rect.bottom > boundsBottom) {
                dy = boundsBottom - rect.bottom;
            }

            if (dx !== 0 || dy !== 0) {
                const currentLeft = parseFloat(menu.style.left || "0");
                const currentTop = parseFloat(menu.style.top || "0");
                menu.style.left = (currentLeft + dx) + "px";
                menu.style.top = (currentTop + dy) + "px";
            }
        } catch (e) {
            // Fallback: bei Fehlern einfach die Grundposition verwenden
        }
    }


    function hideStopMenu() {
        const menu = document.getElementById("stopMenu");
        if (menu) menu.style.display = "none";
        stopMenuIndex = null;
    }

    function toggleDraggableForStop(index) {
        const marker = markers[index];
        if (!marker) return;
        if (currentDraggableMarker && currentDraggableMarker !== marker) {
            currentDraggableMarker.dragging.disable();
            currentDraggableMarker.off("dragend", onMarkerDragEnd);
        }
        marker._dragIndex = index;
        if (!marker.dragging) return;
        marker.dragging.enable();
        marker.off("dragend", onMarkerDragEnd);
        marker.on("dragend", onMarkerDragEnd);
        currentDraggableMarker = marker;
        setPanelStatus("Marker " + (index + 1) + " kann verschoben werden. Nach dem Loslassen wird die Route aktualisiert.");
    }

    function toggleStopActive(index) {
        const stop = stops[index];
        if (!stop) return;

        // Standard: wenn Flag fehlt, als aktiv behandeln
        const currentlyActive = stop.active !== false;
        stop.active = !currentlyActive;

        // Route verwerfen, da sich die Stoppauswahl ge√§ndert hat
        if (routeLayer && map) {
            map.removeLayer(routeLayer);
            routeLayer = null;
        }
        routeComputed = false;
        const panelBody = document.querySelector(".bottom-panel-body");
        const bottomList = document.getElementById("bottomRouteList");
        if (panelBody) panelBody.style.display = "none";
        if (bottomList) bottomList.innerHTML = "";
        setSummary("Gesamt: ‚Äì");

        // Marker-Icons und Liste aktualisieren
        updateMarkerLabels();
        renderStopList();

        if (stop.active === false) {
            setPanelStatus("Stopp " + (index + 1) + " als inaktiv markiert. Klicke unten auf 'Route berechnen', um eine neue Route zu erhalten.");
        } else {
            setPanelStatus("Stopp " + (index + 1) + " wieder aktiviert. Klicke unten auf 'Route berechnen', um eine neue Route zu erhalten.");
        }
    }


    function onMarkerDragEnd(e) {
        const marker = e.target;
        const idx = marker._dragIndex;
        const latLng = marker.getLatLng();
        if (stops[idx]) {
            stops[idx].lat = latLng.lat;
            stops[idx].lon = latLng.lng;
            // Route wird nicht automatisch neu berechnet.
            setPanelStatus("Marker " + (idx + 1) + " verschoben. Klicke unten auf 'Route berechnen'.");
        }
        marker.dragging.disable();
        currentDraggableMarker = null;
    }

    function openStopEditModal(index) {
        const stop = stops[index];
        if (!stop) return;
        currentEditIndex = index;
        document.getElementById("stopEditAddress").value = stop.cleaned || "";
        document.getElementById("stopEditNotes").value = stop.note || "";
        document.getElementById("stopEditEarliest").value = stop.earliest || "";
        document.getElementById("stopEditLatest").value = stop.latest || "";
        document.getElementById("stopEditWindow").value = stop.window || "";
        document.getElementById("stopEditDuration").value = stop.duration || "00:05";

        const beforeSelect = document.getElementById("stopEditBefore");
        const afterSelect = document.getElementById("stopEditAfter");
        beforeSelect.innerHTML = '<option value="">(keine Vorgabe)</option>';
        afterSelect.innerHTML = '<option value="">(keine Vorgabe)</option>';

        stops.forEach((s, idx) => {
            if (idx === index) return;
            const label = (idx + 1) + ". " + s.cleaned;
            const opt1 = document.createElement("option");
            opt1.value = String(idx);
            opt1.textContent = label;
            beforeSelect.appendChild(opt1);
            const opt2 = document.createElement("option");
            opt2.value = String(idx);
            opt2.textContent = label;
            afterSelect.appendChild(opt2);
        });

        if (stop.visitBeforeIndex !== "" && stop.visitBeforeIndex !== null) {
            beforeSelect.value = String(stop.visitBeforeIndex);
        }
        if (stop.visitAfterIndex !== "" && stop.visitAfterIndex !== null) {
            afterSelect.value = String(stop.visitAfterIndex);
        }

        document.getElementById("stopEditModalBackdrop").style.display = "flex";
    }

    function closeStopEditModal() {
        document.getElementById("stopEditModalBackdrop").style.display = "none";
        currentEditIndex = null;
    }

    function repositionStopByVisitHints(originalIndex, beforeIndex, afterIndex) {
        // Passt die Reihenfolge im stops/markers-Array so an, als h√§tte man per Drag & Drop verschoben.
        // "Besuchen vor" hat Vorrang. Wenn nur "Besuchen nach" gesetzt ist, wird dahinter einsortiert.
        if (beforeIndex === null && afterIndex === null) {
            return originalIndex;
        }

        if (originalIndex == null || originalIndex < 0 || originalIndex >= stops.length) {
            return originalIndex;
        }

        const stop = stops[originalIndex];
        const marker = markers[originalIndex];

        // Stopp tempor√§r aus den Arrays entfernen
        stops.splice(originalIndex, 1);
        markers.splice(originalIndex, 1);

        let insertIndex = originalIndex;

        if (beforeIndex !== null) {
            // Ziel ist VOR dem angegebenen Stopp
            if (originalIndex < beforeIndex) {
                insertIndex = beforeIndex - 1;
            } else {
                insertIndex = beforeIndex;
            }
        } else if (afterIndex !== null) {
            // Ziel ist NACH dem angegebenen Stopp
            if (originalIndex < afterIndex) {
                insertIndex = afterIndex;
            } else {
                insertIndex = afterIndex + 1;
            }
        }

        if (insertIndex < 0) insertIndex = 0;
        if (insertIndex > stops.length) insertIndex = stops.length;

        stops.splice(insertIndex, 0, stop);
        markers.splice(insertIndex, 0, marker);

        updateMarkerLabels();
        renderStopList();

        return insertIndex;
    }

    function saveStopEditFromModal() {
        if (currentEditIndex === null) {
            closeStopEditModal();
            return;
        }
        const stop = stops[currentEditIndex];
        if (!stop) {
            closeStopEditModal();
            return;
        }

        const newAddress = document.getElementById("stopEditAddress").value.trim();
        stop.note = document.getElementById("stopEditNotes").value.trim();
        stop.earliest = document.getElementById("stopEditEarliest").value;
        stop.latest = document.getElementById("stopEditLatest").value;
        stop.window = document.getElementById("stopEditWindow").value;
        stop.duration = document.getElementById("stopEditDuration").value || "00:05";

        const beforeSel = document.getElementById("stopEditBefore").value;
        const afterSel = document.getElementById("stopEditAfter").value;
        const beforeIndex = beforeSel === "" ? null : Number(beforeSel);
        const afterIndex = afterSel === "" ? null : Number(afterSel);

        // Werte im Stopp selbst merken (f√ºr Anzeige)
        stop.visitBeforeIndex = beforeIndex === null ? "" : beforeIndex;
        stop.visitAfterIndex = afterIndex === null ? "" : afterIndex;

        const addressChanged = newAddress && newAddress !== stop.cleaned;
        const originalIndex = currentEditIndex;

        const finalizeEdit = () => {
            // Reihenfolge gem√§√ü "Besuchen vor/nach" anpassen
            const newIndex = repositionStopByVisitHints(originalIndex, beforeIndex, afterIndex);

            // Route ggf. automatisch neu berechnen
            const displayIndex = (newIndex != null ? newIndex : originalIndex);
            rerouteIfAlreadyComputed(
                "Stopp " + (displayIndex + 1) + " aktualisiert."
            );

            closeStopEditModal();
        };

        if (addressChanged) {
            stop.cleaned = newAddress;
            stop.raw = newAddress;
            // Erst Adresse geokodieren, DANN Reihenfolge anpassen und ggf. Route neu berechnen
            geocodeSingleStop(originalIndex, () => {
                finalizeEdit();
            });
        } else {
            finalizeEdit();
        }
    }

function updateThemeUI(theme) {
        const themeIcon = document.getElementById("themeIcon");
        const thumb = document.querySelector(".toggle-thumb");
        const themeMeta = document.querySelector('meta[name="theme-color"]');

        // Body-Klassen setzen
        document.body.classList.remove("dark", "pink");
        if (theme === "dark") {
            document.body.classList.add("dark");
        } else if (theme === "pink") {
            document.body.classList.add("pink");
        }

        // Icon setzen
        if (themeIcon) {
            if (theme === "dark") {
                themeIcon.textContent = "üåô";
            } else if (theme === "pink") {
                themeIcon.textContent = "üíñ";
            } else {
                themeIcon.textContent = "üåû";
            }
        }

        // Daumenposition im 3er-Schalter (links = hell, Mitte = dunkel, rechts = pink)
        if (thumb) {
            if (theme === "dark") {
                thumb.style.transform = "translateX(16px)";
            } else if (theme === "pink") {
                thumb.style.transform = "translateX(32px)";
            } else {
                thumb.style.transform = "translateX(0)";
            }
        }

        // App-/Fensterleistenfarbe an das aktuelle Theme anpassen
        if (themeMeta) {
            if (theme === "dark") {
                themeMeta.setAttribute("content", "#0f172a"); // dunkler Header-Ton
            } else if (theme === "pink") {
                themeMeta.setAttribute("content", "#ec4899"); // Haupt-Pink der Men√ºleiste
            } else {
                themeMeta.setAttribute("content", "#0f172a"); // heller Modus nutzt ebenfalls den dunklen Header-Rand
            }
        }
    }

    function applyThemeFromSettings() {
        if (!currentSettings) {
            currentSettings = loadSettings();
        }
        const theme = currentSettings.theme || "light";
        updateThemeUI(theme);
    }

    function toggleTheme() {
        if (!currentSettings) {
            currentSettings = loadSettings();
        }
        const current = currentSettings.theme || "light";
        let next = "light";
        if (current === "light") {
            next = "dark";
        } else if (current === "dark") {
            next = "pink";
        } else {
            next = "light";
        }
        currentSettings.theme = next;
        saveSettings(currentSettings);
        updateThemeUI(next);
    }


document.addEventListener("DOMContentLoaded", () => {
        applyThemeFromSettings();
        initMap();

        const searchInput = document.getElementById("mapSearchInput");
        const searchBtn = document.getElementById("mapSearchBtn");
        if (searchBtn) {
            searchBtn.addEventListener("click", (e) => {
                e.preventDefault();
                searchMapAddress();
            });
        }
        if (searchInput) {
            searchInput.addEventListener("keydown", (e) => {
                if (e.key === "Enter") {
                    e.preventDefault();
                    searchMapAddress();
                }
            });
        }

        const themeToggle = document.getElementById("themeToggle");
        themeToggle.addEventListener("click", toggleTheme);

        document.getElementById("menuImport").addEventListener("click", openImportModal);
        document.getElementById("menuAddresses").addEventListener("click", () => {
            addressesPanelVisible = !addressesPanelVisible;
            document.getElementById("addressesPanel").style.display = addressesPanelVisible ? "flex" : "none";
        });
        document.getElementById("panelCloseBtn").addEventListener("click", () => {
            addressesPanelVisible = !addressesPanelVisible;
            document.getElementById("addressesPanel").style.display = addressesPanelVisible ? "flex" : "none";
        });

        const addressFilterInput = document.getElementById("addressFilterInput");
        if (addressFilterInput) {
            addressFilterInput.addEventListener("input", () => {
                renderStopList();
            });
            addressFilterInput.addEventListener("keydown", (e) => {
                if (e.key === "Escape" && addressFilterInput.value) {
                    addressFilterInput.value = "";
                    renderStopList();
                }
            });
        }

        document.getElementById("modalCloseBtn").addEventListener("click", closeImportModal);
        document.getElementById("modalCancelBtn").addEventListener("click", closeImportModal);
        document.getElementById("modalImportBtn").addEventListener("click", handleImportFromModal);
        const clearListBtn = document.getElementById("clearListBtn");
        if (clearListBtn) {
            clearListBtn.addEventListener("click", () => {
                const ta = document.getElementById("modalAddressInput");
                if (ta) {
                    ta.value = "";
                    updateImportAddressCount();
                }
            });
        }
        document.getElementById("resetBtn").addEventListener("click", resetAll);

        // Zeilenz√§hler f√ºr das Einf√ºhren-Textfeld initialisieren
        const importTextarea = document.getElementById("modalAddressInput");
        if (importTextarea) {
            importTextarea.addEventListener("input", updateImportAddressCount);
            // Startwert setzen (z. B. wenn beim √ñffnen schon Text eingef√ºgt wird)
            updateImportAddressCount();
        }
        const faultyBtn = document.getElementById("faultyBtn");
        if (faultyBtn) {
            faultyBtn.addEventListener("click", openFaultyAddressesInImport);
        }
        const faultyNextBtn = document.getElementById("faultyNextBtn");
        if (faultyNextBtn) {
            faultyNextBtn.addEventListener("click", navigateNextFaulty);
        }

        const faultyWarnCloseBtn = document.getElementById("faultyWarnCloseBtn");
        if (faultyWarnCloseBtn) {
            faultyWarnCloseBtn.addEventListener("click", closeFaultyWarningModal);
        }
        const faultyWarnOkBtn = document.getElementById("faultyWarnOkBtn");
        if (faultyWarnOkBtn) {
            faultyWarnOkBtn.addEventListener("click", closeFaultyWarningModal);
        }
        const faultyWarnHideResolved = document.getElementById("faultyWarnHideResolved");
        if (faultyWarnHideResolved) {
            faultyWarnHideResolved.addEventListener("change", () => {
                if (typeof updateFaultyWarnResolvedVisibility === "function") {
                    updateFaultyWarnResolvedVisibility();
                }
            });
        }

        updateFaultyButton();

        document.getElementById("modalAddressInput").addEventListener("keydown", (e) => {
            if (e.key === "Enter" && (e.ctrlKey || e.metaKey)) {
                e.preventDefault();
                handleImportFromModal();
            }
        });

        document.getElementById("menuPrint").addEventListener("click", handlePrint);
        document.getElementById("menuSave").addEventListener("click", handleSaveRoute);
        document.getElementById("menuDelete").addEventListener("click", handleDeleteRoute);
        document.getElementById("menuRouteCalc").addEventListener("click", handleRouteCalculateClick);
        document.getElementById("menuViewFullRoute").addEventListener("click", focusAllStopsOnMap);
        document.getElementById("menuDim").addEventListener("click", toggleMapDim);

const bottomRoutesImportBtn = document.getElementById("menuRoutesImport");
if (bottomRoutesImportBtn) {
    bottomRoutesImportBtn.addEventListener("click", importRoutesWithFsApi);
}
const bottomRoutesExportBtn = document.getElementById("menuRoutesExport");
if (bottomRoutesExportBtn) {
    bottomRoutesExportBtn.addEventListener("click", exportRoutesWithFsApi);
}


        document.getElementById("menuRoutes").addEventListener("click", openRoutesModal);
        document.getElementById("routesCloseBtn").addEventListener("click", closeRoutesModal);
        document.getElementById("routesCloseBtn2").addEventListener("click", closeRoutesModal);
        document.getElementById("routesClearBtn").addEventListener("click", () => {
            if (confirm("Den gesamten Routenverlauf l√∂schen?")) {
                saveRoutes([]);
                openRoutesModal();
            }
        });
        const routesImportBtn = document.getElementById("routesImportBtn");
        if (routesImportBtn) {
            routesImportBtn.addEventListener("click", () => importRoutesAndFavoritesFromJson("routes"));
        }
        const routesDownloadBtn = document.getElementById("routesDownloadBtn");
        if (routesDownloadBtn) {
            routesDownloadBtn.addEventListener("click", downloadRoutesAndFavoritesCombined);
        }
        const routesFavoritesBtn = document.getElementById("routesFavoritesBtn");
        if (routesFavoritesBtn) {
            routesFavoritesBtn.addEventListener("click", () => {
                closeRoutesModal();
                openFavoritesModal();
            });
        }

        document.getElementById("favoritesCloseBtn").addEventListener("click", closeFavoritesModal);
        document.getElementById("favoritesCloseBtn2").addEventListener("click", closeFavoritesModal);
        document.getElementById("favoritesClearBtn").addEventListener("click", () => {
            if (confirm("Alle Favoriten l√∂schen?")) {
                saveFavorites([]);
                openFavoritesModal();
            }
        });
        const favoritesImportBtn = document.getElementById("favoritesImportBtn");
        if (favoritesImportBtn) {
            favoritesImportBtn.addEventListener("click", () => importRoutesAndFavoritesFromJson("favorites"));
        }
        const favoritesDownloadBtn = document.getElementById("favoritesDownloadBtn");
        if (favoritesDownloadBtn) {
            favoritesDownloadBtn.addEventListener("click", downloadRoutesAndFavoritesCombined);
        }

        document.getElementById("favoriteSaveCloseBtn").addEventListener("click", closeFavoriteSaveModal);
        document.getElementById("favoriteSaveCancelBtn").addEventListener("click", closeFavoriteSaveModal);
        document.getElementById("favoriteSaveConfirmBtn").addEventListener("click", confirmFavoriteSaveFromModal);

        document.getElementById("menuOptions").addEventListener("click", openOptionsModal);
        document.getElementById("optionsCloseBtn").addEventListener("click", closeOptionsModal);
        document.getElementById("optionsSaveBtn").addEventListener("click", saveOptionsFromModal);
        document.getElementById("optionsResetBtn").addEventListener("click", resetOptionsToDefaults);

        // Stop-Men√º-Buttons
        document.getElementById("stopMenuCloseBtn").addEventListener("click", hideStopMenu);
        document.getElementById("stopMenuStartBtn").addEventListener("click", () => {
            if (stopMenuIndex === null) return;
            moveStop(stopMenuIndex, 0);
        });
        document.getElementById("stopMenuEndBtn").addEventListener("click", () => {
            if (stopMenuIndex === null) return;
            moveStop(stopMenuIndex, stops.length - 1);
        });
        
        function deleteStopAtIndex(idx) {
            if (idx === null || idx < 0 || idx >= stops.length) return;
            stops.splice(idx, 1);
            const m = markers.splice(idx, 1)[0];
            if (m && map) {
                map.removeLayer(m);
            }
            updateMarkerLabels();
            renderStopList();
            rebuildFaultyAddressesFromStops();
            updateFaultyButton();
            if (typeof refreshFaultyWarningModalAfterDataChange === "function") {
                refreshFaultyWarningModalAfterDataChange();
            }
            if (routeLayer && map) {
                map.removeLayer(routeLayer);
                routeLayer = null;
            }
            routeComputed = false;
            const panelBody = document.querySelector(".bottom-panel-body");
            const bottomList = document.getElementById("bottomRouteList");
            if (panelBody) panelBody.style.display = "none";
            if (bottomList) bottomList.innerHTML = "";
            setSummary("Gesamt: ‚Äì");
        }
document.getElementById("stopMenuZoomBtn").addEventListener("click", () => {
            if (stopMenuIndex === null) return;
            const m = markers[stopMenuIndex];
            if (m && map) {
                map.setView(m.getLatLng(), 17);
            }
            hideStopMenu();
        });
        document.getElementById("stopMenuMoveBtn").addEventListener("click", () => {
            if (stopMenuIndex === null) return;
            toggleDraggableForStop(stopMenuIndex);
            hideStopMenu();
        });
        document.getElementById("stopMenuStreetBtn").addEventListener("click", () => {
            if (stopMenuIndex === null) return;
            const s = stops[stopMenuIndex];
            if (!s || s.lat === null || s.lon === null) {
                alert("F√ºr diese Adresse liegen noch keine Koordinaten vor.");
                return;
            }
            const url = "https://www.google.com/maps/@?api=1&map_action=pano&viewpoint=" + s.lat + "," + s.lon;
            window.open(url, "_blank");
            hideStopMenu();
        });
        
        document.getElementById("stopMenuToggleActiveBtn").addEventListener("click", () => {
            if (stopMenuIndex === null) return;
            toggleStopActive(stopMenuIndex);
            hideStopMenu();
        });
document.getElementById("stopMenuEditBtn").addEventListener("click", () => {
            if (stopMenuIndex === null) return;
            openStopEditModal(stopMenuIndex);
            hideStopMenu();
        });
        document.getElementById("stopMenuDeleteBtn").addEventListener("click", () => {
            if (stopMenuIndex === null) return;
            const idx = stopMenuIndex;
            deleteStopAtIndex(idx);
            hideStopMenu();
        });

        // Stop bearbeiten Modal
        document.getElementById("stopEditCloseBtn").addEventListener("click", closeStopEditModal);
        document.getElementById("stopEditCancelBtn").addEventListener("click", closeStopEditModal);
        document.getElementById("stopEditSaveBtn").addEventListener("click", saveStopEditFromModal);
        document.getElementById("stopEditDeleteBtn").addEventListener("click", () => {
            if (currentEditIndex === null) {
                closeStopEditModal();
                return;
            }
            const idx = currentEditIndex;
            deleteStopAtIndex(idx);
            closeStopEditModal();
        });

        // Auto-Speichern beim Schlie√üen des Tabs/Fensters
        window.addEventListener("beforeunload", (e) => {
            if (stops.length) {
                persistCurrentRoute(null, "Beenden");
                e.preventDefault();
                e.returnValue = "";
            }
        });
    });
</script>
<script>

    // --- Adressen-Panel Resize (drag on left handle), no persistence ---
    (function initAddressesResize(){
        const panel = document.getElementById('addressesPanel');
        const handle = document.getElementById('addressesResizeHandle');
        if(!panel || !handle) return;
        let dragging = false;
        let startX = 0;
        let startWidth = 0;
        const MIN_W = 260;   // px
        const MAX_W = 720;   // px
        
        const onMove = (e) => {
            if(!dragging) return;
            const dx = startX - (e.touches ? e.touches[0].clientX : e.clientX);
            let newW = Math.min(MAX_W, Math.max(MIN_W, startWidth + dx));
            panel.style.width = newW + 'px';
        };
        const onUp = () => {
            if(!dragging) return;
            dragging = false;
            document.removeEventListener('mousemove', onMove);
            document.removeEventListener('mouseup', onUp);
            document.removeEventListener('touchmove', onMove);
            document.removeEventListener('touchend', onUp);
            document.body.style.userSelect = '';
            document.body.style.cursor = '';
        };
        const onDown = (e) => {
            dragging = true;
            startX = (e.touches ? e.touches[0].clientX : e.clientX);
            // panel is right-aligned; width increases when handle dragged left -> we compute based on current width
            startWidth = panel.getBoundingClientRect().width;
            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onUp);
            document.addEventListener('touchmove', onMove, {passive:false});
            document.addEventListener('touchend', onUp);
            document.body.style.userSelect = 'none';
            document.body.style.cursor = 'ew-resize';
            e.preventDefault();
        };
        handle.addEventListener('mousedown', onDown);
        handle.addEventListener('touchstart', onDown, {passive:false});
        
        // Optional: double click handle to reset to default CSS width (no persistence needed)
        handle.addEventListener('dblclick', () => {
            panel.style.width = '';
        });
    })();

</script>
<script>
    if ("serviceWorker" in navigator) {
        window.addEventListener("load", function () {
            navigator.serviceWorker.register("service-worker.js").catch(function (err) {
                console.warn("Service Worker Registrierung fehlgeschlagen:", err);
            });
        });
    }
</script>
</body>
</html>

